% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/repo_base.R
\name{Repo}
\alias{Repo}
\title{RepoBase class manages ArrayOp objects in one scidb installation}
\description{
A repository for scidb arrays and derived ArrayOp objects that reside in one scidb installation
}
\details{
RepoBase is the base class of scidb-version-specific Repo classes.
Common ogic/behaviors across all supported scidb versions are placed here.
Version-specific logic/behaviors should be implemented in RepoBase sub-classes.
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{.private}}{For internal testing only. Do not access this field to avoid unintended consequences!!!}

\item{\code{setting_ignore_error}}{Whether to ignore internal database errors. Default FALSE.}

\item{\code{setting_ignore_error}}{Whether to ignore internal database errors. Default FALSE.}

\item{\code{setting_use_aio_input}}{Whether to use aio_input for data frame uploading. Default FALSE.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Repo$new()}}
\item \href{#method-query}{\code{Repo$query()}}
\item \href{#method-execute}{\code{Repo$execute()}}
\item \href{#method-get_array}{\code{Repo$get_array()}}
\item \href{#method-register_array}{\code{Repo$register_array()}}
\item \href{#method-load_array_from_scidb}{\code{Repo$load_array_from_scidb()}}
\item \href{#method-load_arrays_from_scidb_namespace}{\code{Repo$load_arrays_from_scidb_namespace()}}
\item \href{#method-load_arrays_from_config}{\code{Repo$load_arrays_from_config()}}
\item \href{#method-upload_df}{\code{Repo$upload_df()}}
\item \href{#method-save_as_array}{\code{Repo$save_as_array()}}
\item \href{#method-.create_array}{\code{Repo$.create_array()}}
\item \href{#method-.remove_array_versions}{\code{Repo$.remove_array_versions()}}
\item \href{#method-.remove_array}{\code{Repo$.remove_array()}}
\item \href{#method-nrow}{\code{Repo$nrow()}}
\item \href{#method-limit}{\code{Repo$limit()}}
\item \href{#method-clone}{\code{Repo$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Initialize function.

Create a new Repo instance

Do NOT call this \code{initialize} function directly. Call \code{newRepo} instead to get a new Repo instance.
Run a query and get a data frame

The query statement \code{stmt} is a string.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$new(dependency_object = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-query"></a>}}
\subsection{Method \code{query()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$query(what, ..., .dry_run = FALSE, .raw = TRUE, .env = parent.frame())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments passed directly to scidb::iquery function}

\item{\code{.dry_run}}{If TRUE, only return evaluated query statement. Default FALSE}

\item{\code{.raw}}{If TRUE and what is a string, do not evaluate, otherwise evaluate \code{what}. Default FALSE.
Only applicable if \code{what} is a string.}

\item{\code{.env}}{An R env or list for R variable substitution}

\item{\code{stmt}}{A string, where
\enumerate{
\item array aliases are replaced by corresponding arrayOp instances
\item functions following arrays are called as arrayOp functions
\item extra arrayOp functions can be provided in parentheses
\item any other variables in \code{.env} will be replaced by its values
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data frame
Execute a query. No result is returned.

The query statement \code{stmt} is a string. No result is returned.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-execute"></a>}}
\subsection{Method \code{execute()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$execute(what, ..., .dry_run = FALSE, .raw = TRUE, .env = parent.frame())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{what}}{A string, where
\enumerate{
\item array aliases are replaced by corresponding arrayOp instances
\item functions following arrays are called as arrayOp functions
\item extra arrayOp functions can be provided in parentheses
\item any other variables in \code{.env} will be replaced by its values
}}

\item{\code{...}}{Arguments passed directly to scidb::iquery function}

\item{\code{.dry_run}}{If TRUE, only return evaluated query statement. Default FALSE}

\item{\code{.raw}}{If TRUE and what is a string, do not evaluate, otherwise evaluate \code{what}. Default FALSE.
Only applicable if \code{what} is a string.}

\item{\code{.env}}{An R env or list for R variable substitution}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
Get an ArrayOp instance

Param \code{what} can be a string or arrayOp instance. If a string, then \code{what} is either a registered array alias,
or raw array schema (e.g. myArray <a:int32, b:string> \link[=d=0:*:0:*]{d=0:\emph{:0:}})

This function is provide unified access of arrayOp instances
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_array"></a>}}
\subsection{Method \code{get_array()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$get_array(what)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{what}}{An array alias, raw array schema or arrayOp instance}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An ArrayOp instance
Register a list of arrays with aliases

Register a list of arrays which can be later accessed via their aliases
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-register_array"></a>}}
\subsection{Method \code{register_array()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$register_array(items)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{items}}{A list where names are aliases and values are arrayOp instances or raw array names
Get an ArrayOp instance from scidb by its full name

No cache is provided with this function.
See \code{register_array} for details on registering an array alias with cache.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-load_array_from_scidb"></a>}}
\subsection{Method \code{load_array_from_scidb()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$load_array_from_scidb(full_array_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{full_array_name}}{A fully qualified array name (e.g. myNamespace.arrayName)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An ArrayOp instance
Get a list of arrays from a scidb namespace
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-load_arrays_from_scidb_namespace"></a>}}
\subsection{Method \code{load_arrays_from_scidb_namespace()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$load_arrays_from_scidb_namespace(namespace)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{namespace}}{A scidb namespace}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of ArrayOp instances where names are the array names (without namespace) and
values are the arrayOp instances whose to_afl() function return fully qualified array names
Load a list of ArrayOp instances from a config object

Only load and return a list of arrayOp instances. Repo's array registery will not be updated.
If desired, you can \verb{loaded = repo$load_arrays_from_config; repo$register_array(loaded)} to register loaded arrays.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-load_arrays_from_config"></a>}}
\subsection{Method \code{load_arrays_from_config()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$load_arrays_from_config(config)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{config}}{A config object (R list) normally loaded from a yaml config file. The config list must have
'namespace' and 'arrays' keys. Value of 'namespace' is a single string for the default namespace.
Value of 'arrays' is a list of unamed elements, where each element is a list of three items:
\enumerate{
\item 'alias': a single string for array alias
\item 'name': raw array name. If without a namespace, then the default namespace is applied.
Otherwise, if in 'namespace.rawArrayName', then use it directly disregard of the default namespace.
\item 'schema': a single string for array schema. E.g. "<aa:string, b:bool null> \link[=da=0:*:0:*]{da=0:\emph{:0:}}
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of ArrayOp instances where names are array aliases and values are the ArrayOp instances
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-upload_df"></a>}}
\subsection{Method \code{upload_df()}}{
Upload a data frame to scidb

Upload a data frame into scidb with data types from the template.
The data frame can have fewer columns than the template, but it can NOT have columns absent in the template.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$upload_df(
  df,
  template,
  temp = TRUE,
  use_aio_input = setting_use_aio_input,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{a data frame whose column names has been sanitized}

\item{\code{template}}{An array alias, schema string, arrayOp; or a named list of data types}

\item{\code{temp}}{Whether to upload the df as a temporary array. Default TRUE.}

\item{\code{use_aio_input}}{Whether to use aio_input for upload. Default FALSE. Same meaning as in scidb::as.scidb}

\item{\code{...}}{Other args passed to scidb::as.scidb, e.g. gc = TRUE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An arrayOp instance with uploaded data.
The resultant arrayOp$to_afl() is the temporary array name R_array****, unless specified explicitly with name='newName'
The resultant arrayOp schema is consisted of 1. artificial dimension(s) from upload or aio_input;
2. attributes whose names are the data frame column names and data types are those in the template.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-save_as_array"></a>}}
\subsection{Method \code{save_as_array()}}{
Save an arrayOp or AFL statement as a scidb array wrapped as a new arrayOp

No all things can be done in one scidb operation, sometimes we need to store intermediate results as arrays.
This is when we need to save materialized arrayOp into a new array, which is then wrapped in a new arrayOp
instance. To get the new array's raw name, call the result \code{arrayOp$to_afl()} function.

The ... params are passed in to scidb::store.
We can specify an array name \code{name='myArray'}(default:a random name in public namespace), create a temporary
array \code{temp=T}(default:F), or suppress auto gc \code{gc=F}(default:T). Refer to scidb documentation for more details.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$save_as_array(what, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{what}}{an arrayOp or an AFL statement (string)}

\item{\code{...}}{Same params as used in scidb::store function, e.g. temp = F, gc = T, name = 'myArray'}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An arrayOp whose \code{to_afl()} is the newly created array name
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.create_array"></a>}}
\subsection{Method \code{.create_array()}}{
Create a new array using the operand's schema
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$.create_array(array_or_alias, new_array_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{array_or_alias}}{The array operand as a template, either an arrayOp isntance or a registered array alias}

\item{\code{new_array_name}}{The new array name. If NULL, it uses the operand's \code{to_afl()} result as the new name.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.remove_array_versions"></a>}}
\subsection{Method \code{.remove_array_versions()}}{
Remove array versions
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$.remove_array_versions(array_or_alias, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{array_or_alias}}{The array operand as a template, either an arrayOp isntance or a registered array alias}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.remove_array"></a>}}
\subsection{Method \code{.remove_array()}}{
Remove array. Careful: Cannot be undone!!!
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$.remove_array(array_or_alias)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{array_or_alias}}{The array operand as a template, either an arrayOp isntance or a registered array alias}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-nrow"></a>}}
\subsection{Method \code{nrow()}}{
Get the number of rows of an arrayOp
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$nrow(what, .raw = TRUE, .env = parent.frame())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{what}}{An arrayOp, raw AFL or R expression string}

\item{\code{.raw}}{If TRUE, and \code{what} is string, treat it as raw AFL. Otherwise parse \code{what} as R expression}

\item{\code{.env}}{The env where \code{what} is evaluated as R expression.
Only applicable when \code{what} is R expression string and \code{.raw = F}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-limit"></a>}}
\subsection{Method \code{limit()}}{
Get the first \code{count} rows of an array
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$limit(what, count, offset = NULL, ..., .raw = TRUE, .env = parent.frame())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{what}}{An arrayOp, raw AFL or R expression string}

\item{\code{count}}{How many rows to take}

\item{\code{offset}}{How many rows to skip before taking}

\item{\code{...}}{Arguments passed directly to scidb::iquery function}

\item{\code{.raw}}{If TRUE, and \code{what} is string, treat it as raw AFL. Otherwise parse \code{what} as R expression}

\item{\code{.env}}{The env where \code{what} is evaluated as R expression.
Only applicable when \code{what} is R expression string and \code{.raw = F}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Repo$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_op_base.R
\name{ArrayOpBase}
\alias{ArrayOpBase}
\title{Base class of all ArrayOp classes}
\description{
ArrayOp classes denote scidb array operations and operands, hence the name.
}
\details{
One operation consists of an scidb operator and \link{1..*} operands, of which the result can be used as an operand
in another operation. Operands and Opreration results can all be denoted by ArrayOp.
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{dims}}{Dimension names}

\item{\code{attrs}}{Attribute names}

\item{\code{selected}}{Selected dimension and/or attribute names}

\item{\code{dtypes}}{A named list, where key is dim/attr name and value is respective SciDB data type as string}

\item{\code{dims_n_attrs}}{Dimension and attribute names}

\item{\code{attrs_n_dims}}{Attribute and dimension names}

\item{\code{is_schema_from_scidb}}{If the array schema is retrieved from SciDB or inferred locally in R}

\item{\code{.private}}{For internal testing only. Do not access this field to avoid unintended consequences!!!}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{ArrayOpBase$new()}}
\item \href{#method-create_new}{\code{ArrayOpBase$create_new()}}
\item \href{#method-filter}{\code{ArrayOpBase$filter()}}
\item \href{#method-select}{\code{ArrayOpBase$select()}}
\item \href{#method-reshape}{\code{ArrayOpBase$reshape()}}
\item \href{#method-change_schema}{\code{ArrayOpBase$change_schema()}}
\item \href{#method-build_new}{\code{ArrayOpBase$build_new()}}
\item \href{#method-set_auto_fields}{\code{ArrayOpBase$set_auto_fields()}}
\item \href{#method-mutate}{\code{ArrayOpBase$mutate()}}
\item \href{#method-transmute}{\code{ArrayOpBase$transmute()}}
\item \href{#method-mutate_by}{\code{ArrayOpBase$mutate_by()}}
\item \href{#method-drop_dims}{\code{ArrayOpBase$drop_dims()}}
\item \href{#method-update}{\code{ArrayOpBase$update()}}
\item \href{#method-overwrite}{\code{ArrayOpBase$overwrite()}}
\item \href{#method-spawn}{\code{ArrayOpBase$spawn()}}
\item \href{#method-limit}{\code{ArrayOpBase$limit()}}
\item \href{#method-row_count}{\code{ArrayOpBase$row_count()}}
\item \href{#method-summarize_array}{\code{ArrayOpBase$summarize_array()}}
\item \href{#method-sync_schema}{\code{ArrayOpBase$sync_schema()}}
\item \href{#method-group_by}{\code{ArrayOpBase$group_by()}}
\item \href{#method-summarize}{\code{ArrayOpBase$summarize()}}
\item \href{#method-to_afl}{\code{ArrayOpBase$to_afl()}}
\item \href{#method-to_schema_str}{\code{ArrayOpBase$to_schema_str()}}
\item \href{#method-to_df_all}{\code{ArrayOpBase$to_df_all()}}
\item \href{#method-to_df}{\code{ArrayOpBase$to_df()}}
\item \href{#method-execute}{\code{ArrayOpBase$execute()}}
\item \href{#method-versions}{\code{ArrayOpBase$versions()}}
\item \href{#method-remove_versions}{\code{ArrayOpBase$remove_versions()}}
\item \href{#method-remove_self}{\code{ArrayOpBase$remove_self()}}
\item \href{#method-inner_join}{\code{ArrayOpBase$inner_join()}}
\item \href{#method-left_join}{\code{ArrayOpBase$left_join()}}
\item \href{#method-right_join}{\code{ArrayOpBase$right_join()}}
\item \href{#method-semi_join}{\code{ArrayOpBase$semi_join()}}
\item \href{#method-persist}{\code{ArrayOpBase$persist()}}
\item \href{#method-is_persistent}{\code{ArrayOpBase$is_persistent()}}
\item \href{#method-exists_persistent_array}{\code{ArrayOpBase$exists_persistent_array()}}
\item \href{#method-array_meta_data}{\code{ArrayOpBase$array_meta_data()}}
\item \href{#method-.set_meta}{\code{ArrayOpBase$.set_meta()}}
\item \href{#method-.get_meta}{\code{ArrayOpBase$.get_meta()}}
\item \href{#method-finalize}{\code{ArrayOpBase$finalize()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Return ArrayOp field types

NOTE: private$info has to be defined, otherwise returns NULL


Get dimension specifications

A dimension spec str is formatted as "lower bound : upper bound : overlap : chunk_length",
as seen in scidb \code{show(array_name)} operator.
All dimensions' data types are int64.


Validate fields existence according the 'type' which defaults to 'owned' fields

This function is useful for validating fields in use cases:


Generate afl for ArrayOp used in a join context (equi_join).


Create a new ArrayOp instance by joining with another ArrayOp

Currently implemented with scidb \code{equi_join} operator.


Create a new ArrayOp by matching a template against a source (self).

The result has the same schema with the source.
All fields in the template are compared to their matching source fields by equality, except for thos in
lower_bound/upper_bound which will be used as a range \verb{[lower_bound, upper_bound]}.


Create a new ArrayOp instance by loading a file and checking it against an ArrayOp template (self).

The ArrayOp instance where this function is called from serves as a template. By defulat, it assumes file
column headers match the template's dims and attrs; otherwise an explicit file_headers can be provided and will
be used to match the template's schema.


Create a new ArrayOp instance that with added auto incremented fields


Create a new ArrayOp instance that has an anti-collision field set according to a template arrayOp

The source (self) operand should have N fields given the target has N+1 dimensions. The one missing field is
treated as the anti-collision field.


Return AFL suitable for retrieving data.frame.

scidb::iquery has a param \code{only_attributes}, which, if set TRUE, will effectively drop all dims.


Returns AFL when self used as an operand in another parent operation.

By default, 1. dimensions are not dropped in parent operation; 2. no intent to select fields


Base class initialize function, to be called in sub-class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$new(
  raw_afl,
  dims = as.character(c()),
  attrs = as.character(c()),
  dtypes = list(),
  dim_specs = list(),
  ...,
  metaList
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field_names}}{R character. If NULL, defaults to \code{self$dims_n_attrs}, ie. dimensions and attributes.}

\item{\code{.raw}}{Default FALSE, full data types are returned; if set TRUE, only the raw data types are returned
(raw data types are string, int32, int64, bool, etc, without scidb attribute specs such as: string compression 'zlib')}

\item{\code{dim_names}}{Default NULL equals all dimensions.}

\item{\code{keyFileds}}{Field names as join keys}

\item{\code{keep_dimensiosn}}{If \code{keep_dimensions} is specified in scidb \code{equi_join} operator}

\item{\code{right}}{The other ArrayOp instance to join with.}

\item{\code{on_left}}{R character vector. Join keys from the left (self).}

\item{\code{on_right}}{R character vector. Join keys from the \code{right}. Must be of the same length as \code{on_left}}

\item{\code{on_both}}{Join keys on both operand.}

\item{\code{.auto_select}}{default: FALSE. If set to TRUE, the resultant ArrayOp instance will auto \code{select} the fields
that are selected in the left and right operands but not in the right join keys (since they are masked by equi_join operator).}

\item{\code{settings}}{\code{equi_join} settings, a named list where both key and values are strings.}

\item{\code{.dim_mode}}{How to reshape the resultant ArrayOp. Same meaning as in \code{ArrayOp$reshape} function.
By default, dim_mode = 'keep', the artificial dimensions, namely \code{instance_id} and \code{value_no} from \code{equi_join}
are retained. If set to 'drop', the artificial dimensions will be removed. See \code{ArrayOp$reshape} for more details.}

\item{\code{.artificial_field}}{As in \code{ArrayOp$reshape}, it defaults to a random field name. It can be safely ignored in
client code. It exists only for test purposes.}

\item{\code{template}}{A data.frame or ArrayOp used to reduce the number of source cells without changing its schema}

\item{\code{op_mode}}{\link{'filter', 'cross_between'}}

\item{\code{lower_bound}}{Field names as lower bounds.}

\item{\code{upper_bound}}{Field names as upper bounds.}

\item{\code{field_mapping}}{A named list where name is source field name and value is template field name.
Default NULL: fields are mapped between template and source by field names only.
If there is mapping fields in the template which are intended for lower or upper bound,
provide an empty list or a list with matching fields}

\item{\code{filepath}}{A single file path}

\item{\code{aio_settings}}{Customized settings of aio_input}

\item{\code{field_conversion}}{If NULL (default), use template's field type to convert aio_input attributes; Or provide
a list for customized field conversion}

\item{\code{file_headers}}{Column headers of the input file regardless of whether there is a header line in the file.
Default NULL assumes file headers match self$dims_n_attrs. If the headers order are different or there are
columns to skip, please provide a string vector, in which case only columns with matching template field are
loaded. Names of the unmatching column headers are irrelevant.}

\item{\code{field_vec}}{A named string vector}

\item{\code{reference}}{ArrayOp instance to draw existing max id from}

\item{\code{source_field}}{}

\item{\code{ref_field}}{}

\item{\code{source_start}}{}

\item{\code{ref_start}}{}

\item{\code{new_field}}{}

\item{\code{target}}{A target arrayOp that the source draws anti-collision dimension from.}

\item{\code{anti_collision_field}}{a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).}

\item{\code{drop_dims}}{Whether self's dimensions are dropped when generating AFL for data.frame conversion}

\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations}

\item{\code{selected_fields}}{which fields are selected no matter what the parent operation is.
If NULL, self fields will pass on by default depending on the parent operation.}

\item{\code{info}}{A list that stores ArrayOp meta data, e.g. field types}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a named list as \code{field_names}, where absent fields or fields without data types will cause error;
unless \code{.strict=F}, absent fields are ignored
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_new"></a>}}
\if{latex}{\out{\hypertarget{method-create_new}{}}}
\subsection{Method \code{create_new()}}{
Return a new arrayOp instance with the same version as \code{self}

Work in sub-class without requiring class names or constructor function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$create_new(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{The samme params with Repo$ArrayOp(...)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-filter"></a>}}
\if{latex}{\out{\hypertarget{method-filter}{}}}
\subsection{Method \code{filter()}}{
Create a new ArrayOp instance by using a filter expression on the parent ArrayOp

Similar to SQL where clause and dplyr::filter.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$filter(
  ...,
  expr,
  missing_fields_error_template = NULL,
  regex_func = getOption("arrayop.regex_func", default = "regex"),
  ignore_case = getOption("arrayop.ignore_case", default = TRUE)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{missing_fields_error_template}}{Error template for missing fields.
Only one \%s is allowed which is substituted with an concatnation of the missing fields separated by commas.}

\item{\code{regex_func}}{A string of regex function implementation.
Due to scidb compatiblity issue with its dependencies, the regex function from boost library may not be available
Supported values: rsub, regex}

\item{\code{ignore_case}}{A Boolean. If TRUE, ignore case in string match patterns.
Otherwise, perform case-sensitive regex matches.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select"></a>}}
\if{latex}{\out{\hypertarget{method-select}{}}}
\subsection{Method \code{select()}}{
Create a new ArrayOp instance with selected fields

NOTE: this does NOT change the to_afl output, but explicitly state which field(s) are retained if used in
a parent operation that changes its schema, e.g. equi_join or to_df(only_attributes = T)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$select(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Which field(s) are retained during a schema-change operation}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reshape"></a>}}
\if{latex}{\out{\hypertarget{method-reshape}{}}}
\subsection{Method \code{reshape()}}{
Create a new ArrayOp instance with a different schema/shape
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$reshape(
  select = NULL,
  dtypes = NULL,
  dim_mode = "keep",
  artificial_field = .random_attr_name(),
  .force_project = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{select}}{Which attributes to select or create.
In dim_mode='keep', \code{select} must be a non-empty list, where named items are derived new attributes and
unamed string values are existing dimensions/attributes. Dimensions, selected or not, are all retained in
dim_mode='keep'.
In dim_mode='drop', \code{select} can be NULL, which effectively select all source dimensions and attributes.
Unselected dimensions will be discarded.}

\item{\code{dtypes}}{a named list to provide field data types for newly derived fields}

\item{\code{dim_mode}}{a string \link{keep, drop}.
In the default 'keep' mode, only attributes can be selected. All dimensions are kept.
In 'drop' mode, dimensions are first converted to attributes, then selected.}

\item{\code{artificial_field}}{ONLY relevant when \code{dim_mode='drop'}.
A field name used as the artificial dimension name in 'drop' dim_mode
(internally used by \code{unpack} scidb operator). By default, a random string is generated.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-change_schema"></a>}}
\if{latex}{\out{\hypertarget{method-change_schema}{}}}
\subsection{Method \code{change_schema()}}{
Change \code{self} schema according to a template

This operation throws away any fields that do not exist in \code{template} while keeping the \code{self}'s data of the
matching fields. Implemented by scidb \code{redimension} operator, but it allows for partial-fields match if \code{strict=F}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$change_schema(template, strict = TRUE, .setting = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{template}}{an arrayOp instance that determines the resultant schema.}

\item{\code{strict}}{If TRUE(default), requires \code{self} has all the \code{template} fields.}

\item{\code{.setting}}{a string vector, where each item will be appended to the redimension operand.
E.g. .setting = c('false', 'cells_per_chunk: 1234') ==> redimension(source, template, false, cells_per_chunk: 1234)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-build_new"></a>}}
\if{latex}{\out{\hypertarget{method-build_new}{}}}
\subsection{Method \code{build_new()}}{
Create a new ArrayOp instance from 'build'ing a data.frame

All matching fields are built as attributes of the result ArrayOp.
Build operator accepts compound attribute types, so the result may have something like "build(<aa:string not null, ...)"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$build_new(df, artificial_field = .random_attr_name())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{a data.frame, where all column names must all validate template fields.}

\item{\code{artificial_field}}{A field name used as the artificial dimension name in \code{build} scidb operator
By default, a random string is generated, and the dimension starts from 0.
A customized dimension can be provided e.g. \verb{z=42:*} or \verb{z=0:*:0:1000}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new ArrayOp instance whose attributes share the same name and data types with the template's fields.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_auto_fields"></a>}}
\if{latex}{\out{\hypertarget{method-set_auto_fields}{}}}
\subsection{Method \code{set_auto_fields()}}{
Create a new ArrayOp instance that has auto incremented fields and/or anti-collision fields according to a template arrayOp

If the dimension count, attribute count and data types match between the source(self) and target,
then no redimension will be performed, otherwise redimension on the source first.

Redimension mode requires all target fields exist on the source disregard of being attributes or dimensions.
Redimension mode does not check on whether source data types match the target because auto data conversion
occurs within scidb where necessary/applicable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$set_auto_fields(
  target,
  source_auto_increment = NULL,
  target_auto_increment = NULL,
  anti_collision_field = NULL,
  join_setting = NULL,
  source_anti_collision_dim_spec = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{A target ArrayOp the source data is written to.}

\item{\code{source_auto_increment}}{a named number vector e.g. c(z=0), where the name is a source field and value is the starting index}

\item{\code{target_auto_increment}}{a named number vector e.g. c(aid=0), where the name is a target field and value is the starting index.
Here the \code{target_auto_increment} param only affects the initial load when the field is still null in the target array.}

\item{\code{anti_collision_field}}{a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mutate"></a>}}
\if{latex}{\out{\hypertarget{method-mutate}{}}}
\subsection{Method \code{mutate()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$mutate(..., .dots = NULL, .sync_schema = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-transmute"></a>}}
\if{latex}{\out{\hypertarget{method-transmute}{}}}
\subsection{Method \code{transmute()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$transmute(..., .dots = NULL, .sync_schema = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mutate_by"></a>}}
\if{latex}{\out{\hypertarget{method-mutate_by}{}}}
\subsection{Method \code{mutate_by()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$mutate_by(
  data_array,
  keys = NULL,
  updated_fields = NULL,
  .redimension_setting = NULL,
  .join_setting = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-drop_dims"></a>}}
\if{latex}{\out{\hypertarget{method-drop_dims}{}}}
\subsection{Method \code{drop_dims()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$drop_dims(
  mode = "unpack",
  .chunk_size = NULL,
  .unpack_dim = dbutils$random_field_name()
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update"></a>}}
\if{latex}{\out{\hypertarget{method-update}{}}}
\subsection{Method \code{update()}}{
Update Target array with self's content

Similar behavior to scidb insert operator
Fields of self and Target must match by raw data type. Field names are irrelevant.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$update(target)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{An arrayOp instance where self's content is written to.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp that encapsulates the insert operation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-overwrite"></a>}}
\if{latex}{\out{\hypertarget{method-overwrite}{}}}
\subsection{Method \code{overwrite()}}{
Overwrite Target array with self's content

Warning: Target's content will be erased and filled with self's content.
Similar behavior to scidb \code{store} operator.
Fields of self and Target must match by raw data type. Field names are irrelevant.
See \code{ArrayOp$change_schema}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$overwrite(target)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{An arrayOp instance where self's content is written to.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp that encapsulates the insert operation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-spawn"></a>}}
\if{latex}{\out{\hypertarget{method-spawn}{}}}
\subsection{Method \code{spawn()}}{
Create a new ArrayOp instance from a \code{self} template

This function is mainly for array schema string generation where we might want to rename and/or exclude certain
fields of the template. Data types and dimension specs will be inherited from the template unless provided.

Note: except for scidb build or aio_input operators, the spawned ArrayOp is not meaningful semantically. So do not
use this function for operations other than 'build'/ArrayOp$build_new and 'aio_input'/ArrayOp$load_file
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$spawn(
  afl_str = "spawned array_op (as template only)",
  renamed = NULL,
  added = NULL,
  excluded = NULL,
  dtypes = NULL,
  dim_specs = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{renamed}}{Rename fields}

\item{\code{added}}{New fields}

\item{\code{excluded}}{Fields to exclude from \code{self}}

\item{\code{dtypes}}{Data types for any existing or new fields, which default to \code{self}'s data types if available.}

\item{\code{dim_specs}}{A list of array dimension specs if dimensions are changed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp instance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-limit"></a>}}
\if{latex}{\out{\hypertarget{method-limit}{}}}
\subsection{Method \code{limit()}}{
Get the first \code{n} rows of an array
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$limit(n = 5, skip = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{How many rows to take}

\item{\code{skip}}{How many rows to skip before taking}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-row_count"></a>}}
\if{latex}{\out{\hypertarget{method-row_count}{}}}
\subsection{Method \code{row_count()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$row_count()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-summarize_array"></a>}}
\if{latex}{\out{\hypertarget{method-summarize_array}{}}}
\subsection{Method \code{summarize_array()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$summarize_array()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sync_schema"></a>}}
\if{latex}{\out{\hypertarget{method-sync_schema}{}}}
\subsection{Method \code{sync_schema()}}{
Create a new array_op with actual schema from SciDB

Useful in confirmming the schema of transient arrays with complex operations
If we are sure the array schema is already from SciDB, then just return self.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$sync_schema()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-group_by"></a>}}
\if{latex}{\out{\hypertarget{method-group_by}{}}}
\subsection{Method \code{group_by()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$group_by(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-summarize"></a>}}
\if{latex}{\out{\hypertarget{method-summarize}{}}}
\subsection{Method \code{summarize()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$summarize(..., .dots = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_afl"></a>}}
\if{latex}{\out{\hypertarget{method-to_afl}{}}}
\subsection{Method \code{to_afl()}}{
AFL representation of the ArrayOp instance

The ArrayOp instance may have 'selected' fields but they are not reflected in the result.
'selected' fields are meaningful in \code{to_df_afl} and \code{.to_afl_explicit} functions, where the parent operation
treats dimension and attributes differently.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_afl()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
an AFL expression string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_schema_str"></a>}}
\if{latex}{\out{\hypertarget{method-to_schema_str}{}}}
\subsection{Method \code{to_schema_str()}}{
Return a schema representation of the ArrayOp <attr1 \link{, attr2 ...}> [dim1 \link{;dim2}]
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_schema_str()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_df_all"></a>}}
\if{latex}{\out{\hypertarget{method-to_df_all}{}}}
\subsection{Method \code{to_df_all()}}{
Run query encapsulated by current array_op and return a R data.frame with
all dimensions and attributes as columns.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_df_all()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_df"></a>}}
\if{latex}{\out{\hypertarget{method-to_df}{}}}
\subsection{Method \code{to_df()}}{
Run query encapsulated by current array_op and return a R data.frame with
all attributes as columns.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_df()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-execute"></a>}}
\if{latex}{\out{\hypertarget{method-execute}{}}}
\subsection{Method \code{execute()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$execute()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-versions"></a>}}
\if{latex}{\out{\hypertarget{method-versions}{}}}
\subsection{Method \code{versions()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$versions()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-remove_versions"></a>}}
\if{latex}{\out{\hypertarget{method-remove_versions}{}}}
\subsection{Method \code{remove_versions()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$remove_versions(version_id = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-remove_self"></a>}}
\if{latex}{\out{\hypertarget{method-remove_self}{}}}
\subsection{Method \code{remove_self()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$remove_self()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-inner_join"></a>}}
\if{latex}{\out{\hypertarget{method-inner_join}{}}}
\subsection{Method \code{inner_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$inner_join(
  right,
  on_left = NULL,
  on_right = NULL,
  on_both = NULL,
  left_alias = "_L",
  right_alias = "_R",
  join_mode = "equi_join",
  settings = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-left_join"></a>}}
\if{latex}{\out{\hypertarget{method-left_join}{}}}
\subsection{Method \code{left_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$left_join(
  right,
  on_left = NULL,
  on_right = NULL,
  on_both = NULL,
  left_alias = "_L",
  right_alias = "_R",
  settings = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-right_join"></a>}}
\if{latex}{\out{\hypertarget{method-right_join}{}}}
\subsection{Method \code{right_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$right_join(
  right,
  on_left = NULL,
  on_right = NULL,
  on_both = NULL,
  left_alias = "_L",
  right_alias = "_R",
  settings = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-semi_join"></a>}}
\if{latex}{\out{\hypertarget{method-semi_join}{}}}
\subsection{Method \code{semi_join()}}{
Similar to dplyr::semi_join

params \code{field_mapping}, \code{lower_bound} and \code{upper_bound}, if provided, must be named list,
where the.names are from the source array (i.e. self), and values are from
the right operand \code{df_or_arrayop}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$semi_join(
  df_or_arrayop,
  field_mapping = NULL,
  lower_bound = NULL,
  upper_bound = NULL,
  mode = "auto",
  filter_threshold = 200L,
  upload_threshold = 6000L
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-persist"></a>}}
\if{latex}{\out{\hypertarget{method-persist}{}}}
\subsection{Method \code{persist()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$persist(save_array_name = NULL, .temp = FALSE, .gc = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_persistent"></a>}}
\if{latex}{\out{\hypertarget{method-is_persistent}{}}}
\subsection{Method \code{is_persistent()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$is_persistent()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-exists_persistent_array"></a>}}
\if{latex}{\out{\hypertarget{method-exists_persistent_array}{}}}
\subsection{Method \code{exists_persistent_array()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$exists_persistent_array()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-array_meta_data"></a>}}
\if{latex}{\out{\hypertarget{method-array_meta_data}{}}}
\subsection{Method \code{array_meta_data()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$array_meta_data()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.set_meta"></a>}}
\if{latex}{\out{\hypertarget{method-.set_meta}{}}}
\subsection{Method \code{.set_meta()}}{
Set ArrayOp meta data directly

Useful in keeping reference of other relevant R objects that should have a same life cycle with the ArrayOp instance.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.set_meta(key, value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{A string key}

\item{\code{value}}{A value of any type}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.get_meta"></a>}}
\if{latex}{\out{\hypertarget{method-.get_meta}{}}}
\subsection{Method \code{.get_meta()}}{
Get ArrayOp meta data directly
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.get_meta(key)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{A string key}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An metadata object of any type registered with \code{key}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-finalize"></a>}}
\if{latex}{\out{\hypertarget{method-finalize}{}}}
\subsection{Method \code{finalize()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$finalize()}\if{html}{\out{</div>}}
}

}
}

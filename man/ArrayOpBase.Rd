% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_op_base.R
\name{ArrayOpBase}
\alias{ArrayOpBase}
\title{Base class of all ArrayOp classes}
\description{
ArrayOp classes denote scidb array operations and operands, hence the name.
}
\details{
One operation consists of an scidb operator and \link{1..*} operands, of which the result can be used as an operand
in another operation. Operands and Opreration results can all be denoted by ArrayOp.
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{dims}}{Dimension names}

\item{\code{attrs}}{Attribute names}

\item{\code{selected}}{Selected dimension and/or attribute names}

\item{\code{dtypes}}{A named list, where key is dim/attr name and value is respective SciDB data type as string}

\item{\code{dims_n_attrs}}{Dimension and attribute names}

\item{\code{attrs_n_dims}}{Attribute and dimension names}

\item{\code{.private}}{For internal testing only. Do not access this field to avoid unintended consequences!!!}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{ArrayOpBase$new()}}
\item \href{#method-get_field_types}{\code{ArrayOpBase$get_field_types()}}
\item \href{#method-get_dim_specs}{\code{ArrayOpBase$get_dim_specs()}}
\item \href{#method-get_absent_fields}{\code{ArrayOpBase$get_absent_fields()}}
\item \href{#method-create_new}{\code{ArrayOpBase$create_new()}}
\item \href{#method-create_new_with_same_schema}{\code{ArrayOpBase$create_new_with_same_schema()}}
\item \href{#method-where}{\code{ArrayOpBase$where()}}
\item \href{#method-select}{\code{ArrayOpBase$select()}}
\item \href{#method-reshape}{\code{ArrayOpBase$reshape()}}
\item \href{#method-change_schema}{\code{ArrayOpBase$change_schema()}}
\item \href{#method-join}{\code{ArrayOpBase$join()}}
\item \href{#method-load_file}{\code{ArrayOpBase$load_file()}}
\item \href{#method-match}{\code{ArrayOpBase$match()}}
\item \href{#method-build_new}{\code{ArrayOpBase$build_new()}}
\item \href{#method-set_auto_increment_field}{\code{ArrayOpBase$set_auto_increment_field()}}
\item \href{#method-set_anti_collision_field}{\code{ArrayOpBase$set_anti_collision_field()}}
\item \href{#method-set_null_fields}{\code{ArrayOpBase$set_null_fields()}}
\item \href{#method-set_auto_fields}{\code{ArrayOpBase$set_auto_fields()}}
\item \href{#method-write_to}{\code{ArrayOpBase$write_to()}}
\item \href{#method-mutate}{\code{ArrayOpBase$mutate()}}
\item \href{#method-update}{\code{ArrayOpBase$update()}}
\item \href{#method-overwrite}{\code{ArrayOpBase$overwrite()}}
\item \href{#method-spawn}{\code{ArrayOpBase$spawn()}}
\item \href{#method-create_array_cmd}{\code{ArrayOpBase$create_array_cmd()}}
\item \href{#method-remove_array_cmd}{\code{ArrayOpBase$remove_array_cmd()}}
\item \href{#method-remove_array_versions_cmd}{\code{ArrayOpBase$remove_array_versions_cmd()}}
\item \href{#method-to_afl}{\code{ArrayOpBase$to_afl()}}
\item \href{#method-to_df_afl}{\code{ArrayOpBase$to_df_afl()}}
\item \href{#method-to_schema_str}{\code{ArrayOpBase$to_schema_str()}}
\item \href{#method-.to_afl_explicit}{\code{ArrayOpBase$.to_afl_explicit()}}
\item \href{#method-.to_join_operand_afl}{\code{ArrayOpBase$.to_join_operand_afl()}}
\item \href{#method-.set_meta}{\code{ArrayOpBase$.set_meta()}}
\item \href{#method-.get_meta}{\code{ArrayOpBase$.get_meta()}}
\item \href{#method-clone}{\code{ArrayOpBase$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Base class initialize function, to be called in sub-class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$new(
  raw_afl,
  dims = as.character(c()),
  attrs = as.character(c()),
  dtypes = list(),
  validate_fields = TRUE,
  dim_specs = list(),
  ...,
  metaList
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{info}}{A list that stores ArrayOp meta data, e.g. field types}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_field_types"></a>}}
\subsection{Method \code{get_field_types()}}{
Return ArrayOp field types

NOTE: private$info has to be defined, otherwise returns NULL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_field_types(field_names = NULL, .strict = TRUE, .raw = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field_names}}{R character. If NULL, defaults to \code{self$dims_n_attrs}, ie. dimensions and attributes.}

\item{\code{.raw}}{Default FALSE, full data types are returned; if set TRUE, only the raw data types are returned
(raw data types are string, int32, int64, bool, etc, without scidb attribute specs such as: string compression 'zlib')}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a named list as \code{field_names}, where absent fields or fields without data types will cause error;
unless \code{.strict=F}, absent fields are ignored
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_dim_specs"></a>}}
\subsection{Method \code{get_dim_specs()}}{
Get dimension specifications

A dimension spec str is formatted as "lower bound : upper bound : overlap : chunk_length",
as seen in scidb \code{show(array_name)} operator.
All dimensions' data types are int64.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_dim_specs(dim_names = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dim_names}}{Default NULL equals all dimensions.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named list where the name is dimension name and value is a dimension spec string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_absent_fields"></a>}}
\subsection{Method \code{get_absent_fields()}}{
Validate fields existence according the 'type' which defaults to 'owned' fields

This function is useful for validating fields in use cases:
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_absent_fields(fieldNames)}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of absent field names
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_new"></a>}}
\subsection{Method \code{create_new()}}{
Return a new arrayOp instance with the same version as \code{self}

Work in sub-class without requiring class names or constructor function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$create_new(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{The samme params with Repo$ArrayOp(...)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_new_with_same_schema"></a>}}
\subsection{Method \code{create_new_with_same_schema()}}{
Create a new ArrayOp instance of the same class

The new instance shares all meta data with the template
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$create_new_with_same_schema(new_afl, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_afl}}{AFL for the new ArrayOp}

\item{\code{...}}{Named params in \code{...} will replace the items in the template's metaList}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-where"></a>}}
\subsection{Method \code{where()}}{
Create a new ArrayOp instance by using a filter expression on the parent ArrayOp

Similar to SQL where clause.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$where(..., expr, missing_fields_error_template = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{missing_fields_error_template}}{Error template for missing fields.
Only one \%s is allowed which is substituted with an concatnation of the missing fields separated by commas.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select"></a>}}
\subsection{Method \code{select()}}{
Create a new ArrayOp instance with selected fields

NOTE: this does NOT change the to_afl output, but explicitly state which field(s) are retained if used in
a parent operation that changes its schema, e.g. equi_join or to_df(only_attributes = T)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$select(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Which field(s) are retained during a schema-change operation}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reshape"></a>}}
\subsection{Method \code{reshape()}}{
Create a new ArrayOp instance with a different schema/shape
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$reshape(
  select = NULL,
  dtypes = NULL,
  dim_mode = "keep",
  artificial_field = .random_attr_name(),
  .force_project = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{select}}{Which attributes to select or create.
In dim_mode='keep', \code{select} must be a non-empty list, where named items are derived new attributes and
unamed string values are existing dimensions/attributes. Dimensions, selected or not, are all retained in
dim_mode='keep'.
In dim_mode='drop', \code{select} can be NULL, which effectively select all source dimensions and attributes.
Unselected dimensions will be discarded.}

\item{\code{dtypes}}{a named list to provide field data types for newly derived fields}

\item{\code{dim_mode}}{a string \link{keep, drop}.
In the default 'keep' mode, only attributes can be selected. All dimensions are kept.
In 'drop' mode, dimensions are first converted to attributes, then selected.}

\item{\code{artificial_field}}{ONLY relevant when \code{dim_mode='drop'}.
A field name used as the artificial dimension name in 'drop' dim_mode
(internally used by \code{unpack} scidb operator). By default, a random string is generated.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-change_schema"></a>}}
\subsection{Method \code{change_schema()}}{
Change \code{self} schema according to a template

This operation throws away any fields that do not exist in \code{template} while keeping the \code{self}'s data of the
matching fields. Implemented by scidb \code{redimension} operator, but it allows for partial-fields match if \code{strict=F}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$change_schema(template, strict = TRUE, .setting = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{template}}{an arrayOp instance that determines the resultant schema.}

\item{\code{strict}}{If TRUE(default), requires \code{self} has all the \code{template} fields.}

\item{\code{.setting}}{a string vector, where each item will be appended to the redimension operand.
E.g. .setting = c('false', 'cells_per_chunk: 1234') ==> redimension(source, template, false, cells_per_chunk: 1234)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-join"></a>}}
\subsection{Method \code{join()}}{
Create a new ArrayOp instance by joining with another ArrayOp

Currently implemented with scidb \code{equi_join} operator.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$join(
  right,
  on_left = NULL,
  on_right = NULL,
  settings = NULL,
  on_both = NULL,
  .auto_select = FALSE,
  join_mode = "equi_join",
  .dim_mode = "keep",
  .left_alias = "_L",
  .right_alias = "_R",
  .artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{right}}{The other ArrayOp instance to join with.}

\item{\code{on_left}}{R character vector. Join keys from the left (self).}

\item{\code{on_right}}{R character vector. Join keys from the \code{right}. Must be of the same length as \code{on_left}}

\item{\code{settings}}{\code{equi_join} settings, a named list where both key and values are strings.}

\item{\code{on_both}}{Join keys on both operand.}

\item{\code{.auto_select}}{default: FALSE. If set to TRUE, the resultant ArrayOp instance will auto \code{select} the fields
that are selected in the left and right operands but not in the right join keys (since they are masked by equi_join operator).}

\item{\code{.dim_mode}}{How to reshape the resultant ArrayOp. Same meaning as in \code{ArrayOp$reshape} function.
By default, dim_mode = 'keep', the artificial dimensions, namely \code{instance_id} and \code{value_no} from \code{equi_join}
are retained. If set to 'drop', the artificial dimensions will be removed. See \code{ArrayOp$reshape} for more details.}

\item{\code{.artificial_field}}{As in \code{ArrayOp$reshpae}, it defaults to a random field name. It can be safely ignored in
client code. It exists only for test purposes.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-load_file"></a>}}
\subsection{Method \code{load_file()}}{
Create a new ArrayOp instance by loading a file and checking it against an ArrayOp template (self).

The ArrayOp instance where this function is called from serves as a template. By defulat, it assumes file
column headers match the template's dims and attrs; otherwise an explicit file_headers can be provided and will
be used to match the template's schema.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$load_file(
  filepath,
  aio_settings = list(),
  field_conversion = NULL,
  file_headers = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{A single file path}

\item{\code{aio_settings}}{Customized settings of aio_input}

\item{\code{field_conversion}}{If NULL (default), use template's field type to convert aio_input attributes; Or provide
a list for customized field conversion}

\item{\code{file_headers}}{Column headers of the input file regardless of whether there is a header line in the file.
Default NULL assumes file headers match self$dims_n_attrs. If the headers order are different or there are
columns to skip, please provide a string vector, in which case only columns with matching template field are
loaded. Names of the unmatching column headers are irrelevant.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new ArrayOp instance with matching fields
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-match"></a>}}
\subsection{Method \code{match()}}{
Create a new ArrayOp by matching a template against a source (self).

The result has the same schema with the source.
All fields in the template are compared to their matching source fields by equality, except for thos in
lower_bound/upper_bound which will be used as a range \verb{[lower_bound, upper_bound]}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$match(
  template,
  op_mode,
  lower_bound = NULL,
  upper_bound = NULL,
  field_mapping = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{template}}{A data.frame or ArrayOp used to reduce the number of source cells without changing its schema}

\item{\code{op_mode}}{\link{'filter', 'cross_between'}}

\item{\code{lower_bound}}{Field names as lower bounds.}

\item{\code{upper_bound}}{Field names as upper bounds.}

\item{\code{field_mapping}}{A named list where name is source field name and value is template field name.
Default NULL: fields are mapped between template and source by field names only.
If there is mapping fields in the template which are intended for lower or upper bound,
provide an empty list or a list with matching fields}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new ArrayOp instance which has the same schema as the source.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-build_new"></a>}}
\subsection{Method \code{build_new()}}{
Create a new ArrayOp instance from 'build'ing a data.frame

All matching fields are built as attributes of the result ArrayOp.
Build operator accepts compound attribute types, so the result may have something like "build(<aa:string not null, ...)"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$build_new(df, artificial_field = .random_attr_name())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{a data.frame, where all column names must all validate template fields.}

\item{\code{artificial_field}}{A field name used as the artificial dimension name in \code{build} scidb operator
By default, a random string is generated, and the dimension starts from 0.
A customized dimension can be provided e.g. \verb{z=42:*} or \verb{z=0:*:0:1000}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new ArrayOp instance whose attributes share the same name and data types with the template's fields.
Create a build expression from a data.frame and specified scidb data types
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_auto_increment_field"></a>}}
\subsection{Method \code{set_auto_increment_field()}}{
Create a new ArrayOp instance that with added auto incremented fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$set_auto_increment_field(
  reference,
  source_field,
  ref_field,
  source_start,
  ref_start,
  new_field = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{reference}}{ArrayOp instance to draw existing max id from}

\item{\code{source_field}}{}

\item{\code{ref_field}}{}

\item{\code{source_start}}{}

\item{\code{ref_start}}{}

\item{\code{new_field}}{}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_anti_collision_field"></a>}}
\subsection{Method \code{set_anti_collision_field()}}{
Create a new ArrayOp instance that has an anti-collision field set according to a template arrayOp

The source (self) operand should have N fields given the target has N+1 dimensions. The one missing field is
treated as the anti-collision field.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$set_anti_collision_field(
  target,
  anti_collision_field = NULL,
  join_setting = NULL,
  source_anti_collision_dim_spec = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{A target arrayOp that the source draws anti-collision dimension from.}

\item{\code{anti_collision_field}}{a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_null_fields"></a>}}
\subsection{Method \code{set_null_fields()}}{
Create a new ArrayOp instance that added null values to the missing fields compared to a reference ArrayOp
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$set_null_fields(reference)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{reference}}{An ArrayOp instance that has fields absent in the source; or a named list.
If reference is ArrayOp, a named list is generated by calling \code{reference$get_field_types(reference$attrs, .raw = T)}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_auto_fields"></a>}}
\subsection{Method \code{set_auto_fields()}}{
Create a new ArrayOp instance that has auto incremented fields and/or anti-collision fields according to a template arrayOp

If the dimension count, attribute count and data types match between the source(self) and target,
then no redimension will be performed, otherwise redimension on the source first.

Redimension mode requires all target fields exist on the source disregard of being attributes or dimensions.
Redimension mode does not check on whether source data types match the target because auto data conversion
occurs within scidb where necessary/applicable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$set_auto_fields(
  target,
  source_auto_increment = NULL,
  target_auto_increment = NULL,
  anti_collision_field = NULL,
  join_setting = NULL,
  source_anti_collision_dim_spec = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{A target ArrayOp the source data is written to.}

\item{\code{source_auto_increment}}{a named number vector e.g. c(z=0), where the name is a source field and value is the starting index}

\item{\code{target_auto_increment}}{a named number vector e.g. c(aid=0), where the name is a target field and value is the starting index.
Here the \code{target_auto_increment} param only affects the initial load when the field is still null in the target array.}

\item{\code{anti_collision_field}}{a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-write_to"></a>}}
\subsection{Method \code{write_to()}}{
(Deprecated) Create a new ArrayOp instance that represents a writing data operation

NOTE: this function is deprecated. DO NOT USE except for legacy code. Will be removed in future versions.
Please use ArrayOp's set_auto_fields, mutate, update and overwrite functions instead.

If the dimension count, attribute count and data types match between the source(self) and target,
then no redimension will be performed, otherwise redimension on the source first.

Redimension mode requires all target fields exist on the source disregard of being attributes or dimensions.
Redimension mode does not check on whether source data types match the target because auto data conversion
occurs within scidb where necessary/applicable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$write_to(
  target,
  append = TRUE,
  force_redimension = TRUE,
  source_auto_increment = NULL,
  target_auto_increment = NULL,
  anti_collision_field = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{A target ArrayOp the source data is written to.}

\item{\code{append}}{Append to existing target array if set to TRUE (default).
Otherwise replace the whole target array with the source.}

\item{\code{force_redimension}}{Redimension the source even if the source fields match perfectly the target fields (default TRUE)}

\item{\code{source_auto_increment}}{a named number vector e.g. c(z=0), where the name is a source field and value is the starting index}

\item{\code{target_auto_increment}}{a named number vector e.g. c(aid=0), where the name is a target field and value is the starting index.
Here the \code{target_auto_increment} param only affects the initial load when the field is still null in the target array.}

\item{\code{anti_collision_field}}{a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mutate"></a>}}
\subsection{Method \code{mutate()}}{
Generate a mutated arrayOp of the source \code{self} by the \code{data_source}.

Neither \code{self} or \code{data_source} is mutated. The resultant arrayOp is a 'mutated' version of \code{self} in the sense
that \code{result} has the exact same schema as \code{self} and a subset of cells that match to \code{self}.

This function works in two modes: 1. \code{data_source} is a named list that specifies the expression for mutation.
2. \code{data_source} is an arrayOp that contains the mutated data and 'key' data for cell identification.

Mode-1: \code{data_source} is a named list.
The \code{data_source} list should only contain names as the mutated fields and string values as the mutate expression.
All other fields not present in the list would remain the same.
Normally, the list should only have \code{self}'s attributes as the mutated fields.
But if \code{data_source} contains target's dimensions, then the number of matching cells should be no more than 1,
otherwise mutiple matching cells would cause dimension collision error thrown by scidb.

Mode-2: \code{data_source} is an arrayOp instance.
The \code{data_source} arrayOp must have two types of data. One type is the 'key' data that are used to identify which
cells to mutate. The other is the 'mutated' data of the matching cells.
If the \code{keys} have all \code{self}'s dimensions, then no join is needed to match cell coordinates.
Otherwise we need to map \code{keys} to cell coordinates using join and redimension.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$mutate(
  data_source,
  keys = NULL,
  updated_fields = NULL,
  artificial_field = .random_attr_name(),
  .redimension_setting = NULL,
  .join_setting = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data_source}}{A named list of mutated field expressions or an arrayOp instance.}

\item{\code{keys}}{Which fields of \code{data_source} to identify the matching cells. Only applicable when \code{data_source} is arrayOp.}

\item{\code{updated_fields}}{Which fields of \code{data_source} to mutate for the matching cells.
Only applicable when \code{data_source} is arrayOp.}

\item{\code{artificial_field}}{The attribute name in unpack if we need to drop \code{self}'s dimensions.
Only applicable when \code{data_source} is a list and contains \code{self}'s dimensions, which is rare.}

\item{\code{.redimension_setting}}{Only applicable when \code{data_source} is arrayOp.}

\item{\code{.join_setting}}{Only applicable when \code{data_source} is arrayOp and it does not have all \code{self}'s dimensions.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a new arrayOp instance that carries the mutated data and has the exact same schema as the target
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update"></a>}}
\subsection{Method \code{update()}}{
Update Target array with self's content

Similar behavior to scidb insert operator
Fields of self and Target must match by raw data type. Field names are irrelevant.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$update(target)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{An arrayOp instance where self's content is written to.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp that encapsulates the insert operation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-overwrite"></a>}}
\subsection{Method \code{overwrite()}}{
Overwrite Target array with self's content

Warning: Target's content will be erased and filled with self's content.
Similar behavior to scidb \code{store} operator.
Fields of self and Target must match by raw data type. Field names are irrelevant.
See \code{ArrayOp$change_schema}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$overwrite(target)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{An arrayOp instance where self's content is written to.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp that encapsulates the insert operation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-spawn"></a>}}
\subsection{Method \code{spawn()}}{
Create a new ArrayOp instance from a \code{self} template

This function is mainly for array schema string generation where we might want to rename and/or exclude certain
fields of the template. Data types and dimension specs will be inherited from the template unless provided.

Note: except for scidb build or aio_input operators, the spawned ArrayOp is not meaningful semantically. So do not
use this function for operations other than 'build'/ArrayOp$build_new and 'aio_input'/ArrayOp$load_file
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$spawn(
  renamed = NULL,
  added = NULL,
  excluded = NULL,
  dtypes = NULL,
  dim_specs = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{renamed}}{Rename fields}

\item{\code{added}}{New fields}

\item{\code{excluded}}{Fields to exclude from \code{self}}

\item{\code{dtypes}}{Data types for any existing or new fields, which default to \code{self}'s data types if available.}

\item{\code{dim_specs}}{A list of array dimension specs if dimensions are changed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new arrayOp instance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_array_cmd"></a>}}
\subsection{Method \code{create_array_cmd()}}{
Generate a command string that creates a new array based on the caller's schema
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$create_array_cmd(array_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{array_name}}{Full array name}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-remove_array_cmd"></a>}}
\subsection{Method \code{remove_array_cmd()}}{
Generate a command string that removes the array (use with CAUTION!!!)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$remove_array_cmd()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-remove_array_versions_cmd"></a>}}
\subsection{Method \code{remove_array_versions_cmd()}}{
Generate a command string that removes the versions of the array (use with CAUTION!!!)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$remove_array_versions_cmd(version_id = NULL)}\if{html}{\out{</div>}}
}

\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_afl"></a>}}
\subsection{Method \code{to_afl()}}{
AFL representation of the ArrayOp instance

The ArrayOp instance may have 'selected' fields but they are not reflected in the result.
'selected' fields are meaningful in \code{to_df_afl} and \code{.to_afl_explicit} functions, where the parent operation
treats dimension and attributes differently.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_afl()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
an AFL expression string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_df_afl"></a>}}
\subsection{Method \code{to_df_afl()}}{
Return AFL suitable for retrieving data.frame.

scidb::iquery has a param \code{only_attributes}, which, if set TRUE, will effectively drop all dims.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_df_afl(
  drop_dims = FALSE,
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self's dimensions are dropped when generating AFL for data.frame conversion}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_schema_str"></a>}}
\subsection{Method \code{to_schema_str()}}{
Return a schema representation of the ArrayOp <attr1 \link{, attr2 ...}> [dim1 \link{;dim2}]
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_schema_str()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.to_afl_explicit"></a>}}
\subsection{Method \code{.to_afl_explicit()}}{
Returns AFL when self used as an operand in another parent operation.

By default, 1. dimensions are not dropped in parent operation; 2. no intent to select fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.to_afl_explicit(
  drop_dims = FALSE,
  selected_fields = NULL,
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations}

\item{\code{selected_fields}}{which fields are selected no matter what the parent operation is.
If NULL, self fields will pass on by default depending on the parent operation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.to_join_operand_afl"></a>}}
\subsection{Method \code{.to_join_operand_afl()}}{
Generate afl for ArrayOp used in a join context (equi_join).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.to_join_operand_afl(
  keyFields,
  keep_dimensions = FALSE,
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keyFileds}}{Field names as join keys}

\item{\code{keep_dimensiosn}}{If \code{keep_dimensions} is specified in scidb \code{equi_join} operator}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.set_meta"></a>}}
\subsection{Method \code{.set_meta()}}{
Set ArrayOp meta data directly

Useful in keeping reference of other relevant R objects that should have a same life cycle with the ArrayOp instance.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.set_meta(key, value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{A string key}

\item{\code{value}}{A value of any type}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.get_meta"></a>}}
\subsection{Method \code{.get_meta()}}{
Get ArrayOp meta data directly
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.get_meta(key)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{key}}{A string key}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An metadata object of any type registered with \code{key}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

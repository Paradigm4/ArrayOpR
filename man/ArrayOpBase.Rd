% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_op_base.R
\name{ArrayOpBase}
\alias{ArrayOpBase}
\title{Base class of all ArrayOp classes}
\description{
ArrayOp classes denote scidb array operations and operands, hence the name.
}
\details{
One operation consists of an scidb operator and \link{1..*} operands, of which the result can be used as an operand
in another operation. Operands and Opreration results can all be denoted by ArrayOp.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{ArrayOpBase$new()}}
\item \href{#method-get_field_types}{\code{ArrayOpBase$get_field_types()}}
\item \href{#method-get_absent_fields}{\code{ArrayOpBase$get_absent_fields()}}
\item \href{#method-create_new}{\code{ArrayOpBase$create_new()}}
\item \href{#method-create_new_with_same_schema}{\code{ArrayOpBase$create_new_with_same_schema()}}
\item \href{#method-where}{\code{ArrayOpBase$where()}}
\item \href{#method-select}{\code{ArrayOpBase$select()}}
\item \href{#method-reshape}{\code{ArrayOpBase$reshape()}}
\item \href{#method-join}{\code{ArrayOpBase$join()}}
\item \href{#method-load_file}{\code{ArrayOpBase$load_file()}}
\item \href{#method-match}{\code{ArrayOpBase$match()}}
\item \href{#method-build_new}{\code{ArrayOpBase$build_new()}}
\item \href{#method-write_to}{\code{ArrayOpBase$write_to()}}
\item \href{#method-to_afl}{\code{ArrayOpBase$to_afl()}}
\item \href{#method-to_df_afl}{\code{ArrayOpBase$to_df_afl()}}
\item \href{#method-.to_afl_explicit}{\code{ArrayOpBase$.to_afl_explicit()}}
\item \href{#method-.to_join_operand_afl}{\code{ArrayOpBase$.to_join_operand_afl()}}
\item \href{#method-clone}{\code{ArrayOpBase$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Base class initialize function, to be called in sub-class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$new(
  raw_afl,
  dims = as.character(c()),
  attrs = as.character(c()),
  dtypes = list(),
  validate_fields = TRUE,
  ...,
  metaList
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{info}}{A list that stores ArrayOp meta data, e.g. field types}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_field_types"></a>}}
\subsection{Method \code{get_field_types()}}{
Return ArrayOp field types

NOTE: private$info has to be defined, otherwise returns NULL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_field_types(field_names = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field_names}}{R character}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a named list as \code{field_names}, where absent fields or fields without data types are dropped silently.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_absent_fields"></a>}}
\subsection{Method \code{get_absent_fields()}}{
Validate fields existence according the 'type' which defaults to 'owned' fields

This function is useful for validating fields in use cases:
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_absent_fields(fieldNames)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_new"></a>}}
\subsection{Method \code{create_new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$create_new(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_new_with_same_schema"></a>}}
\subsection{Method \code{create_new_with_same_schema()}}{
Create a new ArrayOp instance of the same class

The new instance shares all meta data with the template
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$create_new_with_same_schema(new_afl)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-where"></a>}}
\subsection{Method \code{where()}}{
Create a new ArrayOp instance by using a filter expression on the parent ArrayOp

Similar to SQL where clause.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$where(..., expr, missing_fields_error_template = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{missing_fields_error_template}}{Error template for missing fields.
Only one \%s is allowed which is substituted with an concatnation of the missing fields separated by commas.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select"></a>}}
\subsection{Method \code{select()}}{
Create a new ArrayOp instance with selected fields

NOTE: this does NOT change the to_afl output, but explicitly state which field(s) are retained if used in
a parent operation that changes its schema, e.g. equi_join or to_df(only_attributes = T)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$select(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Which field(s) are retained during a schema-change operation}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reshape"></a>}}
\subsection{Method \code{reshape()}}{
Create a new ArrayOp instance with a different schema/shape
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$reshape(
  select,
  dtypes = NULL,
  dim_mode = "keep",
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{select}}{a non-empty list, where named items are new derived attributes and
unamed string values are existing dimensions/attributes.}

\item{\code{dtypes}}{a named list to provide field data types for newly derived fields}

\item{\code{artificial_field}}{A field name used as the artificial dimension name in \code{unpack} scidb operator
By default, a random string is generated.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-join"></a>}}
\subsection{Method \code{join()}}{
Create a new ArrayOp instance by joining with another ArrayOp

Currently implemented with scidb \code{equi_join} operator.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$join(
  right,
  on_left,
  on_right,
  settings = NULL,
  .dim_mode = "keep",
  .artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{right}}{The other ArrayOp instance to join with.}

\item{\code{on_left}}{R character vector. Join keys from the left (self).}

\item{\code{on_right}}{R character vector. Join keys from the \code{right}. Must be of the same length as \code{on_left}}

\item{\code{settings}}{\code{equi_join} settings, a named list where both key and values are strings.}

\item{\code{dim_mode}}{How to reshape the resultant ArrayOp. Same meaning as in \code{ArrayOp$reshape} function.
By default, dim_mode = 'keep', the artificial dimensions, namely \code{instance_id} and \code{value_no} from \code{equi_join}
are retained. If set to 'drop', the artificial dimensions will be removed. See \code{ArrayOp$reshape} for more details.}

\item{\code{artificial_field}}{As in \code{ArrayOp$reshpae}, it defaults to a random field name. It can be safely ignored in
client code. It exists only for test purposes.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-load_file"></a>}}
\subsection{Method \code{load_file()}}{
Create a new ArrayOp instance by loading a file and checking it against an ArrayOp template (self).

The ArrayOp instance where this function is called from serves as a template. By defulat, it assumes file
column headers match the template's dims and attrs; otherwise an explicit file_headers can be provided and will
be used to match the template's schema.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$load_file(
  filepath,
  aio_settings = list(),
  field_conversion = NULL,
  file_headers = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{A single file path}

\item{\code{aio_settings}}{Customized settings of aio_input}

\item{\code{field_conversion}}{If NULL (default), use template's field type to convert aio_input attributes; Or provide
a list for customized field conversion}

\item{\code{file_headers}}{Column headers of the input file regardless of whether there is a header line in the file.
Default NULL assumes file headers match self$dims_n_attrs. If the headers order are different or there are
columns to skip, please provide a string vector, in which case only columns with matching template field are
loaded. Names of the unmatching column headers are irrelevant.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new ArrayOp instance with matching fields
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-match"></a>}}
\subsection{Method \code{match()}}{
Create a new ArrayOp by matching a template against a source (self).

The result has the same schema with the source.
All fields in the template are compared to their matching source fields by equality, except for thos in
lower_bound/upper_bound which will be used as a range \verb{[lower_bound, upper_bound]}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$match(
  template,
  op_mode,
  lower_bound = NULL,
  upper_bound = NULL,
  field_mapping = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{template}}{A data.frame or ArrayOp used to reduce the number of source cells without changing its schema}

\item{\code{op_mode}}{\link{'filter', 'cross_between', 'customized'}}

\item{\code{lower_bound}}{Field names as lower bounds.}

\item{\code{upper_bound}}{Field names as upper bounds.}

\item{\code{field_mapping}}{A named list where name is source field name and value is template field name.
Default NULL: fields are mapped between template and source by field names only.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new ArrayOp instance which has the same schema as the source.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-build_new"></a>}}
\subsection{Method \code{build_new()}}{
Create a new ArrayOp instance from 'build'ing a data.frame

All matching fields are built as attributes of the result ArrayOp.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$build_new(df, artificial_field = .random_attr_name())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{a data.frame, where all column names must all validate template fields.}

\item{\code{artificial_field}}{A field name used as the artificial dimension name in \code{build} scidb operator
By default, a random string is generated, and the dimension starts from 0.
A customized dimension can be provided e.g. 'z=42:\emph{' or 'z=0:}:0:1000'.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new ArrayOp instance whose attributes share the same name and data types with the template's fields.
Create a build expression from a data.frame and specified scidb data types
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-write_to"></a>}}
\subsection{Method \code{write_to()}}{
Create a new ArrayOp instance that represents a writing data operation

If the dimension count, attribute count and data types match between the source(self) and target,
then no redimension will be performed, otherwise redimension on the source first.

Redimension mode requires all target fields exist on the source disregard of being attributes or dimensions.
Redimension mode does not check on whether source data types match the target because auto data conversion
occurs within scidb where necessary/applicable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$write_to(
  target,
  append = TRUE,
  source_auto_increment = NULL,
  target_auto_increment = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target}}{A target ArrayOp the source data is written to.}

\item{\code{append}}{Append to existing target array if set to TRUE (default).
Otherwise replace the whole target array with the source.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_afl"></a>}}
\subsection{Method \code{to_afl()}}{
Return AFL when self used as an operand in another parent operation.

Implemented by calling to_afl_explicit with \code{selected_fields = self$selected}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_afl()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations
By default, dimensions are not dropped in parent operation
But in some operations, dimensions are dropped or converted to attributes
e.g. equi_join creates two artificial dimensions and discard any existing dimensions of two operands.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_df_afl"></a>}}
\subsection{Method \code{to_df_afl()}}{
Return AFL suitable for retrieving data.frame.

scidb::iquery has a param \code{only_attributes}, which, if set TRUE, will effectively drop all dims.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_df_afl(
  drop_dims = FALSE,
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self's dimensions are dropped when generating AFL for data.frame conversion}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.to_afl_explicit"></a>}}
\subsection{Method \code{.to_afl_explicit()}}{
Returns AFL when self used as an operand in another parent operation.

By default, 1. dimensions are not dropped in parent operation; 2. no intent to select fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.to_afl_explicit(
  drop_dims = FALSE,
  selected_fields = NULL,
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations}

\item{\code{selected_fields}}{which fields are selected no matter what the parent operation is.
If NULL, self fields will pass on by default depending on the parent operation.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.to_join_operand_afl"></a>}}
\subsection{Method \code{.to_join_operand_afl()}}{
Generate afl for ArrayOp used in a join context (equi_join).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.to_join_operand_afl(
  keyFields,
  keep_dimensions = FALSE,
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keyFileds}}{Field names as join keys}

\item{\code{keep_dimensiosn}}{If \code{keep_dimensions} is specified in scidb \code{equi_join} operator}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

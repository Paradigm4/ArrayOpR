% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_op_base.R
\name{ArrayOpBase}
\alias{ArrayOpBase}
\title{Base class of all ArrayOp classes}
\description{
ArrayOp classes denote scidb array operations and operands, hence the name.
}
\details{
One operation consists of an scidb operator and \link{1..*} operands, of which the result can be used as an operand
in another operation. Operands and Opreration results can all be denoted by ArrayOp.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{ArrayOpBase$new()}}
\item \href{#method-get_field_types}{\code{ArrayOpBase$get_field_types()}}
\item \href{#method-get_absent_fields}{\code{ArrayOpBase$get_absent_fields()}}
\item \href{#method-create_new}{\code{ArrayOpBase$create_new()}}
\item \href{#method-duplicate_with_same_specs}{\code{ArrayOpBase$duplicate_with_same_specs()}}
\item \href{#method-where}{\code{ArrayOpBase$where()}}
\item \href{#method-select}{\code{ArrayOpBase$select()}}
\item \href{#method-reshape}{\code{ArrayOpBase$reshape()}}
\item \href{#method-join}{\code{ArrayOpBase$join()}}
\item \href{#method-to_afl}{\code{ArrayOpBase$to_afl()}}
\item \href{#method-to_df_afl}{\code{ArrayOpBase$to_df_afl()}}
\item \href{#method-.raw_afl}{\code{ArrayOpBase$.raw_afl()}}
\item \href{#method-.to_afl_explicit}{\code{ArrayOpBase$.to_afl_explicit()}}
\item \href{#method-to_join_operand_afl}{\code{ArrayOpBase$to_join_operand_afl()}}
\item \href{#method-transform_unpack}{\code{ArrayOpBase$transform_unpack()}}
\item \href{#method-convert_df}{\code{ArrayOpBase$convert_df()}}
\item \href{#method-rename_fields}{\code{ArrayOpBase$rename_fields()}}
\item \href{#method-clone}{\code{ArrayOpBase$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Base class initialize function, to be called in sub-class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$new(
  raw_afl,
  dims = as.character(c()),
  attrs = as.character(c()),
  dtypes = list(),
  validate_fields = TRUE,
  ...,
  metaList
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{info}}{A list that stores ArrayOp meta data, e.g. field types}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_field_types"></a>}}
\subsection{Method \code{get_field_types()}}{
Return ArrayOp field types

NOTE: private$info has to be defined, otherwise returns NULL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_field_types(field_names = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field_names}}{R character}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a named list as \code{field_names}, where absent fields or fields without data types are dropped silently.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_absent_fields"></a>}}
\subsection{Method \code{get_absent_fields()}}{
Validate fields existence according the 'type' which defaults to 'owned' fields

This function is useful for validating fields in use cases:
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_absent_fields(fieldNames)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_new"></a>}}
\subsection{Method \code{create_new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$create_new(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-duplicate_with_same_specs"></a>}}
\subsection{Method \code{duplicate_with_same_specs()}}{
Create a new ArrayOp instance of the same class

The new instance shares all meta data with the template
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$duplicate_with_same_specs(new_afl)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-where"></a>}}
\subsection{Method \code{where()}}{
Create a new ArrayOp instance by using a filter expression on the parent ArrayOp

Similar to SQL where clause.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$where(..., expr, missing_fields_error_template = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{missing_fields_error_template}}{Error template for missing fields.
Only one \%s is allowed which is substituted with an concatnation of the missing fields separated by commas.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-select"></a>}}
\subsection{Method \code{select()}}{
Create a new ArrayOp instance with selected fields

NOTE: this does NOT change the to_afl output, but explicitly state which field(s) are retained if used in
a parent operation that changes its schema, e.g. equi_join or to_df(only_attributes = T)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$select(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Which field(s) are retained during a schema-change operation}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reshape"></a>}}
\subsection{Method \code{reshape()}}{
Create a new ArrayOp instance with a different schema/shape
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$reshape(
  select,
  dtypes = NULL,
  dim_mode = "keep",
  artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{select}}{a non-empty list, where named items are new derived attributes and
unamed string values are existing dimensions/attributes.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-join"></a>}}
\subsection{Method \code{join()}}{
Create a new ArrayOp instance by joining with another ArrayOp

Currently implemented with scidb \code{equi_join} operator.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$join(
  right,
  on_left,
  on_right,
  settings = NULL,
  .dim_mode = "keep",
  .artificial_field = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{right}}{The other ArrayOp instance to join with.}

\item{\code{on_left}}{R character vector. Join keys from the left (self).}

\item{\code{on_right}}{R character vector. Join keys from the \code{right}. Must be of the same length as \code{on_left}}

\item{\code{settings}}{\code{equi_join} settings, a named list where both key and values are strings.}

\item{\code{dim_mode}}{How to reshape the resultant ArrayOp. Same meaning as in \code{ArrayOp$reshape} function.
By default, dim_mode = 'keep', the artificial dimensions, namely \code{instance_id} and \code{value_no} from \code{equi_join}
are retained. If set to 'drop', the artificial dimensions will be removed. See \code{ArrayOp$reshape} for more details.}

\item{\code{artificial_field}}{As in \code{ArrayOp$reshpae}, it defaults to a random field name. It can be safely ignored in
client code. It exists only for test purposes.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_afl"></a>}}
\subsection{Method \code{to_afl()}}{
Return AFL when self used as an operand in another parent operation.

Implemented by calling to_afl_explicit with \code{selected_fields = self$selected}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_afl()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations
By default, dimensions are not dropped in parent operation
But in some operations, dimensions are dropped or converted to attributes
e.g. equi_join creates two artificial dimensions and discard any existing dimensions of two operands.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_df_afl"></a>}}
\subsection{Method \code{to_df_afl()}}{
Return AFL suitable for retrieving data.frame.

scidb::iquery has a param \code{only_attributes}, which, if set TRUE, will effectively drop all dims.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_df_afl(drop_dims = FALSE, artificial_attr = .random_attr_name())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self's dimensions are dropped when generating AFL for data.frame conversion}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.raw_afl"></a>}}
\subsection{Method \code{.raw_afl()}}{
Functions below translate array operations into SciDb AFL expressions/statements.

NOTE: this method do not take into acount field selection
Sub-classes should override this function.
Doing so equips sub-classes with sensible behavior defined below.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.raw_afl()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
AFL when self used as an operand in another parent operation without considering fields selection
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.to_afl_explicit"></a>}}
\subsection{Method \code{.to_afl_explicit()}}{
Returns AFL when self used as an operand in another parent operation.

By default, 1. dimensions are not dropped in parent operation; 2. no intent to select fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.to_afl_explicit(
  drop_dims = FALSE,
  selected_fields = NULL,
  artificial_attr = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations}

\item{\code{selected_fields}}{which fields are selected no matter what the parent operation is.
If NULL, self fields will pass on by default depending on the parent operation.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_join_operand_afl"></a>}}
\subsection{Method \code{to_join_operand_afl()}}{
Generate afl for ArrayOp used in a join context (equi_join).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_join_operand_afl(
  keyFields,
  keep_dimensions = FALSE,
  artificial_attr = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keyFileds}}{Field names as join keys}

\item{\code{keep_dimensiosn}}{If \code{keep_dimensions} is specified in scidb \code{equi_join} operator}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-transform_unpack"></a>}}
\subsection{Method \code{transform_unpack()}}{
Create a CustomizedOp with a changed schema. Implemented with scidb \code{unpack} operator

**NOTE:**Allow adding new fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$transform_unpack(fields, dtypes = list(), unpack_dim_name = "z")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{A non-empty list where named items are new attributes and
string values without names are existing dim/attribute}

\item{\code{dtypes}}{A named list of fieldName:fieldType for newly create fields}

\item{\code{unpack_dim_name}}{Customized dimension name in scidb \code{unpack} operator.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A CustomizedOp instance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-convert_df"></a>}}
\subsection{Method \code{convert_df()}}{
Convert a data.frame to a CustomizedOp that matches self's fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$convert_df(
  operand,
  mode,
  missing_values = list(),
  validate_fields = TRUE,
  build_dimension = "j"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{operand}}{a data.frame}

\item{\code{mode}}{'build' or 'upload'.
'build' mode is implemented with scidb \code{build} operator;
'upload' mode first upload the data.frame as an array, then add missing fields if needed.}

\item{\code{build_dimension}}{A string used as the dimension name of \code{build} operation. Only applicable in 'build' mode.}

\item{\code{missing_fields}}{A named list specifying missing field expressions}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A CustomizedOp that can be used in WriteOp
Create a build expression from a data.frame and specified scidb data types
Convert a single value to its proper string representation in \code{build} expressions.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rename_fields"></a>}}
\subsection{Method \code{rename_fields()}}{
Create a new CustomizedOp using the same schema data type but renamed fields (ie. dimensions and/or attributes)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$rename_fields(name_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name_list}}{A named list. list(old_field_name = 'new_field_name', ...)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A Customized instance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_op_base_old.R
\name{ArrayOpBase}
\alias{ArrayOpBase}
\title{Base class of all ArrayOp classes}
\description{
ArrayOp classes denote scidb array operations and operands, hence the name.
}
\details{
One operation consists of an scidb operator and \link{1..*} operands, of which the result can be used as an operand
in another operation. Operands and Opreration results can all be denoted by ArrayOp.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{ArrayOpBase$new()}}
\item \href{#method-get_field_types}{\code{ArrayOpBase$get_field_types()}}
\item \href{#method-get_absent_fields}{\code{ArrayOpBase$get_absent_fields()}}
\item \href{#method-validate_filter_expr}{\code{ArrayOpBase$validate_filter_expr()}}
\item \href{#method-.raw_afl}{\code{ArrayOpBase$.raw_afl()}}
\item \href{#method-.to_afl_explicit}{\code{ArrayOpBase$.to_afl_explicit()}}
\item \href{#method-to_afl}{\code{ArrayOpBase$to_afl()}}
\item \href{#method-to_df_afl}{\code{ArrayOpBase$to_df_afl()}}
\item \href{#method-to_join_operand_afl}{\code{ArrayOpBase$to_join_operand_afl()}}
\item \href{#method-transform_unpack}{\code{ArrayOpBase$transform_unpack()}}
\item \href{#method-convert_df}{\code{ArrayOpBase$convert_df()}}
\item \href{#method-rename_fields}{\code{ArrayOpBase$rename_fields()}}
\item \href{#method-clone}{\code{ArrayOpBase$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Base class initialize function, to be called in sub-class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$new(info = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{info}}{A list that stores ArrayOp meta data, e.g. field types}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_field_types"></a>}}
\subsection{Method \code{get_field_types()}}{
Return ArrayOp field types

NOTE: private$info has to be defined, otherwise returns NULL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_field_types(field_names)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field_names}}{R character}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a named list as \code{field_names}, where absent fields or fields without data types are dropped silently.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_absent_fields"></a>}}
\subsection{Method \code{get_absent_fields()}}{
Validate fields existence according the 'type' which defaults to 'owned' fields

This function is useful for validating fields in use cases:
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$get_absent_fields(fieldNames)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-validate_filter_expr"></a>}}
\subsection{Method \code{validate_filter_expr()}}{
Validate a filter expression ('filterExpr' must be a single R call expression)

Current only report errors on:
\enumerate{
\item Name symbols that are not existing schema fields
\item Non-atomic 'values'
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$validate_filter_expr(filterExpr)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filterExpr}}{An rlang::expr}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list object with named elements:
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.raw_afl"></a>}}
\subsection{Method \code{.raw_afl()}}{
Functions below translate array operations into SciDb AFL expressions/statements.

NOTE: this method do not take into acount field selection
Sub-classes should override this function.
Doing so equips sub-classes with sensible behavior defined below.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.raw_afl()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
AFL when self used as an operand in another parent operation without considering fields selection
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-.to_afl_explicit"></a>}}
\subsection{Method \code{.to_afl_explicit()}}{
Returns AFL when self used as an operand in another parent operation.

By default, 1. dimensions are not dropped in parent operation; 2. no intent to select fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$.to_afl_explicit(
  drop_dims = FALSE,
  selected_fields = NULL,
  artificial_attr = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations}

\item{\code{selected_fields}}{which fields are selected no matter what the parent operation is.
If NULL, self fields will pass on by default depending on the parent operation.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_afl"></a>}}
\subsection{Method \code{to_afl()}}{
Return AFL when self used as an operand in another parent operation.

Implemented by calling to_afl_explicit with \code{selected_fields = self$selected}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_afl(drop_dims = FALSE, artificial_attr = .random_attr_name())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self dimensions will be dropped in parent operations
By default, dimensions are not dropped in parent operation
But in some operations, dimensions are dropped or converted to attributes
e.g. equi_join creates two artificial dimensions and discard any existing dimensions of two operands.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_df_afl"></a>}}
\subsection{Method \code{to_df_afl()}}{
Return AFL suitable for retrieving data.frame.

scidb::iquery has a param \code{only_attributes}, which, if set TRUE, will effectively drop all dims.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_df_afl(drop_dims = FALSE, artificial_attr = .random_attr_name())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{drop_dims}}{Whether self's dimensions are dropped when generating AFL for data.frame conversion}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
AFL string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-to_join_operand_afl"></a>}}
\subsection{Method \code{to_join_operand_afl()}}{
Generate afl for ArrayOp used in a join context (equi_join).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$to_join_operand_afl(
  keyFields,
  keep_dimensions = FALSE,
  artificial_attr = .random_attr_name()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keyFileds}}{Field names as join keys}

\item{\code{keep_dimensiosn}}{If \code{keep_dimensions} is specified in scidb \code{equi_join} operator}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-transform_unpack"></a>}}
\subsection{Method \code{transform_unpack()}}{
Create a CustomizedOp with a changed schema. Implemented with scidb \code{unpack} operator

**NOTE:**Allow adding new fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$transform_unpack(fields, dtypes = list(), unpack_dim_name = "z")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{A non-empty list where named items are new attributes and
string values without names are existing dim/attribute}

\item{\code{dtypes}}{A named list of fieldName:fieldType for newly create fields}

\item{\code{unpack_dim_name}}{Customized dimension name in scidb \code{unpack} operator.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A CustomizedOp instance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-convert_df"></a>}}
\subsection{Method \code{convert_df()}}{
Convert a data.frame to a CustomizedOp that matches self's fields
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$convert_df(
  operand,
  mode,
  missing_values = list(),
  validate_fields = TRUE,
  build_dimension = "j"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{operand}}{a data.frame}

\item{\code{mode}}{'build' or 'upload'.
'build' mode is implemented with scidb \code{build} operator;
'upload' mode first upload the data.frame as an array, then add missing fields if needed.}

\item{\code{build_dimension}}{A string used as the dimension name of \code{build} operation. Only applicable in 'build' mode.}

\item{\code{missing_fields}}{A named list specifying missing field expressions}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A CustomizedOp that can be used in WriteOp
Create a build expression from a data.frame and specified scidb data types
Convert a single value to its proper string representation in \code{build} expressions.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rename_fields"></a>}}
\subsection{Method \code{rename_fields()}}{
Create a new CustomizedOp using the same schema data type but renamed fields (ie. dimensions and/or attributes)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$rename_fields(name_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name_list}}{A named list. list(old_field_name = 'new_field_name', ...)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A Customized instance
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ArrayOpBase$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_op_base.R
\docType{data}
\name{ArrayOpBase}
\alias{ArrayOpBase}
\title{Base class of all ArrayOp classes}
\format{An object of class \code{R6ClassGenerator} of length 25.}
\usage{
ArrayOpBase
}
\arguments{
\item{info}{A list that stores ArrayOp meta data, e.g. field types}

\item{field_names}{R character. If NULL, defaults to \code{self$dims_n_attrs}, ie. dimensions and attributes.}

\item{.raw}{Default FALSE, full data types are returned; if set TRUE, only the raw data types are returned
(raw data types are string, int32, int64, bool, etc, without scidb attribute specs such as: string compression 'zlib')}

\item{dim_names}{Default NULL equals all dimensions.}

\item{new_afl}{AFL for the new ArrayOp}

\item{...}{Named params in \code{...} will replace the items in the template's metaList}

\item{missing_fields_error_template}{Error template for missing fields.
Only one %s is allowed which is substituted with an concatnation of the missing fields separated by commas.}

\item{...}{Which field(s) are retained during a schema-change operation}

\item{select}{a non-empty list, where named items are new derived attributes and
unamed string values are existing dimensions/attributes.}

\item{dtypes}{a named list to provide field data types for newly derived fields}

\item{artificial_field}{A field name used as the artificial dimension name in \code{unpack} scidb operator
By default, a random string is generated.}

\item{right}{The other ArrayOp instance to join with.}

\item{on_left}{R character vector. Join keys from the left (self).}

\item{on_right}{R character vector. Join keys from the \code{right}. Must be of the same length as \code{on_left}}

\item{on_both}{Join keys on both operand.}

\item{.auto_select}{default: FALSE. If set to TRUE, the resultant ArrayOp instance will auto \code{select} the fields
that are selected in the left and right operands but not in the right join keys (since they are masked by equi_join operator).}

\item{settings}{\code{equi_join} settings, a named list where both key and values are strings.}

\item{.dim_mode}{How to reshape the resultant ArrayOp. Same meaning as in \code{ArrayOp$reshape} function.
By default, dim_mode = 'keep', the artificial dimensions, namely \code{instance_id} and \code{value_no} from \code{equi_join}
are retained. If set to 'drop', the artificial dimensions will be removed. See \code{ArrayOp$reshape} for more details.}

\item{.artificial_field}{As in \code{ArrayOp$reshpae}, it defaults to a random field name. It can be safely ignored in
client code. It exists only for test purposes.}

\item{filepath}{A single file path}

\item{aio_settings}{Customized settings of aio_input}

\item{field_conversion}{If NULL (default), use template's field type to convert aio_input attributes; Or provide
a list for customized field conversion}

\item{file_headers}{Column headers of the input file regardless of whether there is a header line in the file.
Default NULL assumes file headers match self$dims_n_attrs. If the headers order are different or there are
columns to skip, please provide a string vector, in which case only columns with matching template field are
loaded. Names of the unmatching column headers are irrelevant.}

\item{template}{A data.frame or ArrayOp used to reduce the number of source cells without changing its schema}

\item{op_mode}{\link{'filter', 'cross_between'}}

\item{lower_bound}{Field names as lower bounds.}

\item{upper_bound}{Field names as upper bounds.}

\item{field_mapping}{A named list where name is source field name and value is template field name.
Default NULL: fields are mapped between template and source by field names only.
If there is mapping fields in the template which are intended for lower or upper bound,
provide an empty list or a list with matching fields}

\item{df}{a data.frame, where all column names must all validate template fields.}

\item{artificial_field}{A field name used as the artificial dimension name in \code{build} scidb operator
By default, a random string is generated, and the dimension starts from 0.
A customized dimension can be provided e.g. 'z=42:\emph{' or 'z=0:}:0:1000'.}

\item{reference}{ArrayOp instance to draw existing max id from}

\item{source_field}{}

\item{ref_field}{}

\item{source_start}{}

\item{ref_start}{}

\item{new_field}{}

\item{target}{A target ArrayOp the source data is written to.}

\item{append}{Append to existing target array if set to TRUE (default).
Otherwise replace the whole target array with the source.}

\item{force_redimension}{Redimension the source even if the source fields match perfectly the target fields (default TRUE)}

\item{source_auto_increment}{a named number vector e.g. c(z=0), where the name is a source field and value is the starting index}

\item{target_auto_increment}{a named number vector e.g. c(aid=0), where the name is a target field and value is the starting index.
Here the \code{target_auto_increment} param only affects the initial load when the field is still null in the target array.}

\item{anti_collision_field}{a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).}

\item{drop_dims}{Whether self's dimensions are dropped when generating AFL for data.frame conversion}

\item{drop_dims}{Whether self dimensions will be dropped in parent operations}

\item{selected_fields}{which fields are selected no matter what the parent operation is.
If NULL, self fields will pass on by default depending on the parent operation.}

\item{keyFileds}{Field names as join keys}

\item{keep_dimensiosn}{If \code{keep_dimensions} is specified in scidb \code{equi_join} operator}
}
\value{
a named list as \code{field_names}, where absent fields or fields without data types will cause error;
unless \code{.strict=F}, absent fields are ignored

A named list where the name is dimension name and value is a dimension spec string

A new ArrayOp instance with matching fields

A new ArrayOp instance which has the same schema as the source.

A new ArrayOp instance whose attributes share the same name and data types with the template's fields.
Create a build expression from a data.frame and specified scidb data types

an AFL expression string

AFL string

AFL string
}
\description{
ArrayOp classes denote scidb array operations and operands, hence the name.

Base class initialize function, to be called in sub-class

Return ArrayOp field types

NOTE: private$info has to be defined, otherwise returns NULL

Get dimension specifications

A dimension spec str is formatted as "lower bound : upper bound : overlap : chunk_length",
as seen in scidb \code{show(array_name)} operator.
All dimensions' data types are int64.

Validate fields existence according the 'type' which defaults to 'owned' fields

This function is useful for validating fields in use cases:

Create a new ArrayOp instance of the same class

The new instance shares all meta data with the template

Create a new ArrayOp instance by using a filter expression on the parent ArrayOp

Similar to SQL where clause.

Create a new ArrayOp instance with selected fields

NOTE: this does NOT change the to_afl output, but explicitly state which field(s) are retained if used in
a parent operation that changes its schema, e.g. equi_join or to_df(only_attributes = T)

Create a new ArrayOp instance with a different schema/shape

Create a new ArrayOp instance by joining with another ArrayOp

Currently implemented with scidb \code{equi_join} operator.

Create a new ArrayOp instance by loading a file and checking it against an ArrayOp template (self).

The ArrayOp instance where this function is called from serves as a template. By defulat, it assumes file
column headers match the template's dims and attrs; otherwise an explicit file_headers can be provided and will
be used to match the template's schema.

Create a new ArrayOp by matching a template against a source (self).

The result has the same schema with the source.
All fields in the template are compared to their matching source fields by equality, except for thos in
lower_bound/upper_bound which will be used as a range \code{[lower_bound, upper_bound]}.

Create a new ArrayOp instance from 'build'ing a data.frame

All matching fields are built as attributes of the result ArrayOp.
Build operator accepts compound attribute types, so the result may have something like "build(<aa:string not null, ...)"

Create a new ArrayOp instance that with added auto incremented fields

Create a new ArrayOp instance that represents a writing data operation

If the dimension count, attribute count and data types match between the source(self) and target,
then no redimension will be performed, otherwise redimension on the source first.

Redimension mode requires all target fields exist on the source disregard of being attributes or dimensions.
Redimension mode does not check on whether source data types match the target because auto data conversion
occurs within scidb where necessary/applicable.

Create a new ArrayOp instance from a \code{self} template

This function is mainly for array schema string generation where we might want to rename and/or exclude certain
fields of the template. Data types and dimension specs will be inherited from the template unless provided.

Note: except for scidb build or aio_input operators, the spawned ArrayOp is not meaningful semantically. So do not
use this function for operations other than 'build'/ArrayOp$build_new and 'aio_input'/ArrayOp$load_file

Generate a command string that creates a new array based on the caller's schema

Generate a command string that removes the array (use with CAUTION!!!)

Generate a command string that removes the versions of the array (use with CAUTION!!!)

AFL representation of the ArrayOp instance

The ArrayOp instance may have 'selected' fields but they are not reflected in the result.
'selected' fields are meaningful in \code{to_df_afl} and \code{.to_afl_explicit} functions, where the parent operation
treats dimension and attributes differently.

Return AFL suitable for retrieving data.frame.

scidb::iquery has a param \code{only_attributes}, which, if set TRUE, will effectively drop all dims.

Return a schema representation of the ArrayOp <attr1 \link{, attr2 ...}> [dim1 \link{;dim2}]

Returns AFL when self used as an operand in another parent operation.

By default, 1. dimensions are not dropped in parent operation; 2. no intent to select fields

Generate afl for ArrayOp used in a join context (equi_join).

Set ArrayOp meta data directly

Get ArrayOp meta data directly
}
\details{
One operation consists of an scidb operator and \link{1..*} operands, of which the result can be used as an operand
in another operation. Operands and Opreration results can all be denoted by ArrayOp.
}
\keyword{datasets}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/afl_utils.R
\name{AFLUtils}
\alias{AFLUtils}
\title{AFL utility functions}
\description{
Normally we don't need these functions.
But in case we do, they are flexible in constructing high-order
AFL expressions, e.g. AFL raw string or expressions generated in one place and
used in other places with or without modification.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-e_to_afl}{\code{AFLUtils$e_to_afl()}}
\item \href{#method-args_to_expressions}{\code{AFLUtils$args_to_expressions()}}
\item \href{#method-e}{\code{AFLUtils$e()}}
\item \href{#method-e_merge}{\code{AFLUtils$e_merge()}}
\item \href{#method-join_fields}{\code{AFLUtils$join_fields()}}
\item \href{#method-validate_filter_expr}{\code{AFLUtils$validate_filter_expr()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-e_to_afl"></a>}}
\if{latex}{\out{\hypertarget{method-e_to_afl}{}}}
\subsection{Method \code{e_to_afl()}}{
Convert filter expression(s) to AFL filter
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AFLUtils$e_to_afl(e, regex_func = "regex", ignore_case = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{e}}{A list of R expression(s). If more than one expression is provided,
they will be joined with logic AND.}

\item{\code{regex_func}}{A string of regex function implementation, default 'regex'.
Due to scidb compatiblity issue with its dependencies, the regex function from boost library may not be available
Currently supported options include 'rsub', and 'regex'}

\item{\code{ignore_case}}{A Boolean, default TRUE. If TRUE, ignore case in string match patterns.
Otherwise, perform case-sensitive regex matches.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An AFL filter string
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-args_to_expressions"></a>}}
\if{latex}{\out{\hypertarget{method-args_to_expressions}{}}}
\subsection{Method \code{args_to_expressions()}}{
Convert API ... args to an R expression vector (deprecated)

Some API functions include ... arg to represent arbitrary search criteria.
This provides flexibility and simplifies API function signatures, but only supports limited advanced search,
e.g. xxx_contains, xxx_range, xxx_not.

Eg. name_contains = 'str' => name \%contains\% 'str'
Eg. value_range = c(1, 9) => c(value >= 1, value <= 9)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AFLUtils$args_to_expressions(..., .dots = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{API ellipsis args}

\item{\code{.dots}}{Explicitly provide a parameter list. If not NULL, the ellipsis params are ignored}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of AFL expressions in R
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-e"></a>}}
\if{latex}{\out{\hypertarget{method-e}{}}}
\subsection{Method \code{e()}}{
Create a list of R expressions

The ... ellipsis arg can include arbitrary expressions, where all names are preserved in their literal forms,
\strong{except} for those prefixed with !! (double exclamation marks) which will be evaluated to their actual values
in the calling environment.

Besides common comparison operators including \code{==}, \code{>}, \code{<}, \code{>=}, \code{<=}, \code{!=}, there are a few special operators
supported to ease AFL generation:
\itemize{
\item \code{\%in\%} semantically similar to R. \code{a \%in\% !!c(1,2,3)} will be translated to \verb{(a == 1 or a == 2 or a == 3)}
\item \verb{\%like\%} for string regex matching.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AFLUtils$e(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{The ellipsis arg can have multiple items as expressions, but NO named items as in a named list.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of R expressions
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-e_merge"></a>}}
\if{latex}{\out{\hypertarget{method-e_merge}{}}}
\subsection{Method \code{e_merge()}}{
Merge multiple R expressions into one

Merge an ExprsList into a single Expression so that it can be used as a FilterExpr
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AFLUtils$e_merge(el, mode = "AND")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{el}}{A list of R expressions}

\item{\code{mode}}{'AND' | 'OR'. Logical relationships when merging the expressions.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
R expression
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-join_fields"></a>}}
\if{latex}{\out{\hypertarget{method-join_fields}{}}}
\subsection{Method \code{join_fields()}}{
Just multple fields with sep = ','

Default behavior: \code{paste(..., sep = sep, collapse = sep)} where \code{sep = ','}

afl(...) will convert vectors to joined strings separated by \verb{,}.
This function is useful in concatenating multiple vectors in parallel,
e.g. joining a new field vector and expression vector for the \code{apply} operator.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AFLUtils$join_fields(..., sep = ",")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Multiple string vectors}

\item{\code{sep}}{A single character string, defaullt ",", as field separator.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-validate_filter_expr"></a>}}
\if{latex}{\out{\hypertarget{method-validate_filter_expr}{}}}
\subsection{Method \code{validate_filter_expr()}}{
Validate a filter expression

Current only report errors on:
\enumerate{
\item Name symbols that are not known schema fields, defined by
param \code{all_fields}
\item Non-atomic R 'values' in the expression
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AFLUtils$validate_filter_expr(filter_expr, all_fields)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filter_expr}}{AFL captured as a single R expression}

\item{\code{all_fields}}{A list of strings as the scope of valid fields}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list object with named elements:
success:bool, absent_fields: c(''), error_msgs: c('')
}
}
}

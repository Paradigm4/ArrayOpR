% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/afl_utils.R
\name{afl}
\alias{afl}
\title{Create AFL expressions from R expressions}
\usage{
afl(..., envir = parent.frame())
}
\arguments{
\item{...}{In the ellipsis arg, any R functions right after a pipe sign `|`` is converted to
a scidb operator of the same name.
All regular functions are first evaluated in the calling environment, and then convereted to strings
depending on the result types.
ArrayOp => ArrayOp$to_afl(), v:NonEmptyVector => paste(v, collapse=','),
NULL is ignored.}

\item{envir}{The environment where expressions are evaluated. Default: the calling env.}
}
\value{
AFL string
}
\description{
This is a convenience function for AFL generation.
}
\details{
Any \code{a | op_name(b)} call will be translated to \code{op_name(a, b)} in R, then translated to AFL:
\code{op_name(a, b)}

Any \code{a | op_name } call will be translated to \code{op_name(a)} in R, then translated to AFL:
\code{op_name(a)}

Where \code{a}, \code{b} can be any ArrayOpBase instance, array name or array opertion or AFL expression;
\code{op_name} can be any scidb operator or function name.

Using this syntax, we can chain multiple AFL operators

E.g.1. \code{'array' | filter('a > 3 and b < 4') | project('a', 'b')}
will be translated into: \verb{project(filter(array, a > 3 and b < 4), 'a', 'b')}

E.g.2.\code{'array' | filter(a > 3) | op_count} => \code{op_count(filter(array, a > 3))}
}

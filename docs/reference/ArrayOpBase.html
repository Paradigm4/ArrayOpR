<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>ArrayOp base class that encapsulates a scidb array or array operations — ArrayOpBase • arrayop</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="ArrayOp base class that encapsulates a scidb array or array operations — ArrayOpBase" />
<meta property="og:description" content="ArrayOp class instances denote scidb array operations and operands, hence the name.
Operands can be plain scidb array names or (potentially nested) operations on arrays.
Most ArrayOp class methods return a new ArrayOp instance and the original
instance on which methods are invoked from remains the same,
i.e. ArrayOp instances are immutable." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">arrayop</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/arrayop.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/semi_join.html">Semi Join</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/Paradigm4/ArrayOpR/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>ArrayOp base class that encapsulates a scidb array or array operations</h1>
    <small class="dont-index">Source: <a href='https://github.com/Paradigm4/ArrayOpR/blob/master/R/array_op_base.R'><code>R/array_op_base.R</code></a></small>
    <div class="hidden name"><code>ArrayOpBase.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>ArrayOp class instances denote scidb array operations and operands, hence the name.</p>
<p>Operands can be plain scidb array names or (potentially nested) operations on arrays.</p>
<p>Most ArrayOp class methods return a new ArrayOp instance and the original
instance on which methods are invoked from remains the same,
i.e. ArrayOp instances are immutable.</p>
    </div>



    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>One ArrayOp operation may involve one or multiple scidb operators and any number of operands.
in another operation. Operands and Opreration results can all be denoted by ArrayOp.</p>
<p>Sub-classes of ArrayOpBase deal with any syntax or operator changes in different
SciDB version so that the ArrayOpBase class can provide a unified API on all
supported SciDB versions. Currently SciDB V18 and V19 are supported.</p>
<p>Users of <code>arrayop</code> package shouldn't be concerned with a specific sub-class since
the <code>ScidbConnection</code> object automatically chooses the correct class version
and creates instances based on the scidb version it connects to.</p>
<p>Get arrayOp instances from the default ScidbConnection object.
See <code><a href='get_default_connection.html'>arrayop::get_default_connection</a></code> for details.</p>
    <h2 class="hasAnchor" id="active-bindings"><a class="anchor" href="#active-bindings"></a>Active bindings</h2>

    <p><div class="r6-active-bindings"></p><dl>
<dt><code>dims</code></dt><dd><p>Dimension names</p></dd>

<dt><code>attrs</code></dt><dd><p>Attribute names</p></dd>

<dt><code>selected</code></dt><dd><p>Selected dimension and/or attribute names</p></dd>

<dt><code>dtypes</code></dt><dd><p>A named list, where key is dim/attr name and value is respective SciDB data type as string</p></dd>

<dt><code>raw_dtypes</code></dt><dd><p>A named list, where key is dim/attr name and value is first part of respective SciDB data type as string</p></dd>

<dt><code>dims_n_attrs</code></dt><dd><p>Dimension and attribute names</p></dd>

<dt><code>attrs_n_dims</code></dt><dd><p>Attribute and dimension names</p></dd>

<dt><code>is_schema_from_scidb</code></dt><dd><p>If the array schema is retrieved from SciDB or inferred locally in R</p></dd>

<dt><code>is_scidb_data_frame</code></dt><dd><p>Whether current array_op is a regular array or
SciDB data frame (array with hidden dimensions; not to be confused with R data frames)</p></dd>

<dt><code>.private</code></dt><dd><p>For internal testing only. Do not access this field to avoid unintended consequences!!!</p></dd>

</dl><p></div></p>
    <h2 class="hasAnchor" id="methods"><a class="anchor" href="#methods"></a>Methods</h2>

    
<h3>Public methods</h3>

<ul>
<li><p><a href='#method-new'><code>ArrayOpBase$new()</code></a></p></li>
<li><p><a href='#method-filter'><code>ArrayOpBase$filter()</code></a></p></li>
<li><p><a href='#method-mutate'><code>ArrayOpBase$mutate()</code></a></p></li>
<li><p><a href='#method-transmute'><code>ArrayOpBase$transmute()</code></a></p></li>
<li><p><a href='#method-mutate_by'><code>ArrayOpBase$mutate_by()</code></a></p></li>
<li><p><a href='#method-inner_join'><code>ArrayOpBase$inner_join()</code></a></p></li>
<li><p><a href='#method-left_join'><code>ArrayOpBase$left_join()</code></a></p></li>
<li><p><a href='#method-right_join'><code>ArrayOpBase$right_join()</code></a></p></li>
<li><p><a href='#method-semi_join'><code>ArrayOpBase$semi_join()</code></a></p></li>
<li><p><a href='#method-group_by'><code>ArrayOpBase$group_by()</code></a></p></li>
<li><p><a href='#method-summarize'><code>ArrayOpBase$summarize()</code></a></p></li>
<li><p><a href='#method-set_auto_fields'><code>ArrayOpBase$set_auto_fields()</code></a></p></li>
<li><p><a href='#method-update'><code>ArrayOpBase$update()</code></a></p></li>
<li><p><a href='#method-overwrite'><code>ArrayOpBase$overwrite()</code></a></p></li>
<li><p><a href='#method-select'><code>ArrayOpBase$select()</code></a></p></li>
<li><p><a href='#method-to_df_all'><code>ArrayOpBase$to_df_all()</code></a></p></li>
<li><p><a href='#method-to_df'><code>ArrayOpBase$to_df()</code></a></p></li>
<li><p><a href='#method-execute'><code>ArrayOpBase$execute()</code></a></p></li>
<li><p><a href='#method-persist'><code>ArrayOpBase$persist()</code></a></p></li>
<li><p><a href='#method-change_schema'><code>ArrayOpBase$change_schema()</code></a></p></li>
<li><p><a href='#method-drop_dims'><code>ArrayOpBase$drop_dims()</code></a></p></li>
<li><p><a href='#method-sync_schema'><code>ArrayOpBase$sync_schema()</code></a></p></li>
<li><p><a href='#method-spawn'><code>ArrayOpBase$spawn()</code></a></p></li>
<li><p><a href='#method-to_afl'><code>ArrayOpBase$to_afl()</code></a></p></li>
<li><p><a href='#method-to_schema_str'><code>ArrayOpBase$to_schema_str()</code></a></p></li>
<li><p><a href='#method-limit'><code>ArrayOpBase$limit()</code></a></p></li>
<li><p><a href='#method-cell_count'><code>ArrayOpBase$cell_count()</code></a></p></li>
<li><p><a href='#method-summarize_array'><code>ArrayOpBase$summarize_array()</code></a></p></li>
<li><p><a href='#method-versions'><code>ArrayOpBase$versions()</code></a></p></li>
<li><p><a href='#method-get_version_snapshot'><code>ArrayOpBase$get_version_snapshot()</code></a></p></li>
<li><p><a href='#method-is_persistent'><code>ArrayOpBase$is_persistent()</code></a></p></li>
<li><p><a href='#method-exists_persistent_array'><code>ArrayOpBase$exists_persistent_array()</code></a></p></li>
<li><p><a href='#method-array_meta_data'><code>ArrayOpBase$array_meta_data()</code></a></p></li>
<li><p><a href='#method-remove_versions'><code>ArrayOpBase$remove_versions()</code></a></p></li>
<li><p><a href='#method-remove_array'><code>ArrayOpBase$remove_array()</code></a></p></li>
<li><p><a href='#method-finalize'><code>ArrayOpBase$finalize()</code></a></p></li>
</ul>
<p><hr>
<a id="method-new"></a></p><h3>Method <code>new()</code></h3>
<p>Base class initialize function, to be called in sub-class internally.</p>
<p>Always use <code>ScidbConnection</code> to get array_op instances.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>new</span>(
  <span class='no'>raw_afl</span>,
  <span class='kw'>dims</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/character.html'>as.character</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>()),
  <span class='kw'>attrs</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/character.html'>as.character</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>()),
  <span class='kw'>dtypes</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(),
  <span class='kw'>dim_specs</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(),
  <span class='no'>...</span>,
  <span class='no'>meta_list</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>raw_afl</code></dt><dd><p>AFL expression (array name or operations) as string</p></dd>

<dt><code>dims</code></dt><dd><p>A string vector used as dimension names</p></dd>

<dt><code>attrs</code></dt><dd><p>A string vector used as attribute names</p></dd>

<dt><code>dtypes</code></dt><dd><p>A named list of strings, where names are attribute names and
values are full scidb data types.
E.g. <code>dtypes = list(field_str = "string NOT NULL", field_int32 = "int32")</code></p></dd>

<dt><code>dim_specs</code></dt><dd><p>A named list of string, where names are dimension names
and values are dimension specs.
E.g. <code>dim_sepcs = list(da = "0:*:0:*", chrom = "1:24:0:1")</code>.</p></dd>

<dt><code>...</code></dt><dd><p>A  named list of metadata items, where names are used as keys
in <code>private$set_meta</code> and <code>private$get_meta</code> functions.</p></dd>

<dt><code>meta_list</code></dt><dd><p>A list that stores ArrayOp meta data, e.g. field types
If provided, other regular parms are not allowed.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-filter"></a></p><h3>Method <code><a href='https://rdrr.io/r/stats/filter.html'>filter()</a></code></h3>
<p>Create a new ArrayOp instance with filter expressions</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/filter.html'>dplyr::filter</a></code>, fields are not quoted.</p>
<p>Operators for any type of fields include <code>==</code>, <code>!=</code>,
<code>%in%</code>, <code>%not_in%</code>.
To test whether a field is null, use unary operators: <code>is_null</code>, <code>not_null</code>.</p>
<p>Special binary operators for string fields include:
<code>%contains%</code>, <code>%starts_with%</code>, <code>%ends_with%</code>, <code>%like%</code>, where
only <code>%like%</code> takes a regular expression and other operators escape any special
characters in the right operand.</p>
<p>Operators for numeric fields include: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'><a href='https://rdrr.io/r/stats/filter.html'>filter</a></span>(
  <span class='no'>...</span>,
  <span class='kw'>.expr</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.validate_fields</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
  <span class='kw'>.regex_func</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span>(<span class='st'>"arrayop.regex_func"</span>, <span class='kw'>default</span> <span class='kw'>=</span> <span class='st'>"regex"</span>),
  <span class='kw'>.ignore_case</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span>(<span class='st'>"arrayop.ignore_case"</span>, <span class='kw'>default</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>Filter expression(s) in R syntax.
These expression(s) are not evaluated in R but first captured then converted to scidb expressions with appropriate syntax.</p></dd>

<dt><code>.expr</code></dt><dd><p>A single R expression, or a list of R exprs, or NULL.
If provided, <code>...</code> is ignored. Mutiple exprs are joined by 'and'.
This param is useful when we want to pass an already captured R expression.</p></dd>

<dt><code>.validate_fields</code></dt><dd><p>Boolean, default TURE, whether to validate fields
in filter epxressions. Throw error if invalid fields exist when set to TRUE.</p></dd>

<dt><code>.regex_func</code></dt><dd><p>A string of regex function implementation, default 'regex'.
Due to scidb compatiblity issue with its dependencies, the regex function from boost library may not be available
Currently supported options include 'rsub', and 'regex'</p></dd>

<dt><code>.ignore_case</code></dt><dd><p>A Boolean, default TRUE. If TRUE, ignore case in string match patterns.
Otherwise, perform case-sensitive regex matches.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp</p>
<p><hr>
<a id="method-mutate"></a></p><h3>Method <code>mutate()</code></h3>
<p>Create a new ArrayOp instance with mutated fields</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate.html'>dplyr::mutate</a></code>, fields of source (self) can be removed or added to the result arrayOp
Any field that are not in the mutate expressions remain unchanged.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>mutate</span>(<span class='no'>...</span>, <span class='kw'>.dots</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>.sync_schema</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>Named R expressions. Names are field names in the result arrayOp and must not be empty.
Set field = NULL to remove existing fields. E.g. <code>abcd = NULL, def = def</code> removes
field 'abcd' and keep field 'def'.Values are R expressions similar to the <code>filter</code> method.
E.g. <code>a = b + 2, name = first + "-" + last, chrom = if(chrom == 'x') 23 else if(chrom == 'y') 24 else chrom</code></p></dd>

<dt><code>.dots</code></dt><dd><p>A named list of R expressions or NULL. If provided,
the <code>...</code> param is ignored. Useful when an a list of mutation expressions is already
created and can be passed around.</p></dd>

<dt><code>.sync_schema</code></dt><dd><p>Whether to get the exact schema from scidb. Default
TRUE will cause a scidb query to get the schema. Set to FALSE to avoid schema checking.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>a new ArrayOp instance</p>
<p><hr>
<a id="method-transmute"></a></p><h3>Method <code>transmute()</code></h3>
<p>Create a new ArrayOp instance with mutated fields</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate.html'>dplyr::transmute</a></code>, only listed fields are retained in the result arrayOp
NOTE: Any field that are not in the mutate expressions will be discarded.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>transmute</span>(<span class='no'>...</span>, <span class='kw'>.dots</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>.sync_schema</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>R expressions. Names are optional.
For each named expression, the name is used as field name in the result arrayOp.
Unnamed expressions must be existing field names, unquoted, which result in unchanged source fields of self.Values are R expressions similar to the <code>filter</code> method.
E.g. <code>a = b + 2, name = first + "-" + last, chrom = if(chrom == 'x') 23 else if(chrom == 'y') 24 else chrom</code></p></dd>

<dt><code>.dots</code></dt><dd><p>A named list of R expressions or NULL. If provided,
the <code>...</code> param is ignored. Useful when an a list of mutation expressions is already
created and can be passed around.</p></dd>

<dt><code>.sync_schema</code></dt><dd><p>Whether to get the exact schema from scidb. Default
TRUE will cause a scidb query to get the schema. Set to FALSE to avoid schema checking.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>a new ArrayOp instance</p>
<p><hr>
<a id="method-mutate_by"></a></p><h3>Method <code>mutate_by()</code></h3>
<p>Create a ArrayOp instance with the same schema of self, but different cells
from 'data_array' for the 'updated_fields'.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>mutate_by</span>(
  <span class='no'>data_array</span>,
  <span class='kw'>keys</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>updated_fields</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.redimension_setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.join_setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>data_array</code></dt><dd><p>An ArrayOp instance that have at least two overlapping fields with self.</p></dd>

<dt><code>keys</code></dt><dd><p>Field names in both self and data_array. Cell content of these
fields are from the 'self' arrayOp rather than 'data_array'.</p></dd>

<dt><code>updated_fields</code></dt><dd><p>Field names in both self and data_array. Cell content
of these fields are from the 'data_array', NOT 'self'.</p></dd>

<dt><code>.redimension_setting</code></dt><dd><p>A list of strings used as the settings of scidb
'redimension' operator. Only applicable when a 'redimension' is needed.</p></dd>

<dt><code>.join_setting</code></dt><dd><p>A list of strings used as the settings of scidb
'join' operator. Only applicable when a 'join' is needed.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp with the same schema as self</p>
<p><hr>
<a id="method-inner_join"></a></p><h3>Method <code>inner_join()</code></h3>
<p>Inner join two arrays: 'self' (left) and 'right'</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate-joins.html'>dplyr::inner_join</a></code>, the result arrayOp performs an inner join.
For both left and right arrays, only selected fields are included in the result arrayOp.
If no fields are selected, then all fields are treated as selected.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>inner_join</span>(
  <span class='no'>right</span>,
  <span class='kw'>by.x</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>by.y</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>by</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>left_alias</span> <span class='kw'>=</span> <span class='st'>"_L"</span>,
  <span class='kw'>right_alias</span> <span class='kw'>=</span> <span class='st'>"_R"</span>,
  <span class='kw'>join_mode</span> <span class='kw'>=</span> <span class='st'>"equi_join"</span>,
  <span class='kw'>settings</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>right</code></dt><dd><p>An arrayOp instance</p></dd>

<dt><code>by.x</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>by.y</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>by</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'. If not NULL,
must be fields of both operands.</p></dd>

<dt><code>left_alias</code></dt><dd><p>Alias for left array to resolve potential conflicting fields in result</p></dd>

<dt><code>right_alias</code></dt><dd><p>Alias for right array to resolve potential conflicting fields in result</p></dd>

<dt><code>join_mode</code></dt><dd><p>String 'equi_join' or 'cross_join'. The latter requires
join keys are all dimensions of both operands, which is more strigenet than 'equi_join'
with the benifit of non-materializing result in scidb.</p></dd>

<dt><code>settings</code></dt><dd><p>A named list as join settings. E.g. <code><a href='https://rdrr.io/r/base/list.html'> list(algorithm = "'hash_replicate_right'")</a></code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-left_join"></a></p><h3>Method <code>left_join()</code></h3>
<p>Left join two arrays: 'self' (left) and 'right'</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate-joins.html'>dplyr::left_join</a></code>, the result arrayOp performs a left join.
For both left and right arrays, only selected fields are included in the result arrayOp.
If no fields are selected, then all fields are treated as selected.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>left_join</span>(
  <span class='no'>right</span>,
  <span class='kw'>by.x</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>by.y</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>by</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>left_alias</span> <span class='kw'>=</span> <span class='st'>"_L"</span>,
  <span class='kw'>right_alias</span> <span class='kw'>=</span> <span class='st'>"_R"</span>,
  <span class='kw'>settings</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>right</code></dt><dd><p>An arrayOp instance</p></dd>

<dt><code>by.x</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>by.y</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>by</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'. If not NULL,
must be fields of both operands.</p></dd>

<dt><code>left_alias</code></dt><dd><p>Alias for left array to resolve potential conflicting fields in result</p></dd>

<dt><code>right_alias</code></dt><dd><p>Alias for right array to resolve potential conflicting fields in result</p></dd>

<dt><code>settings</code></dt><dd><p>A named list as join settings. E.g. <code><a href='https://rdrr.io/r/base/list.html'> list(algorithm = "'hash_replicate_right'")</a></code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-right_join"></a></p><h3>Method <code>right_join()</code></h3>
<p>Right join two arrays: 'self' (left) and 'right'</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate-joins.html'>dplyr::right_join</a></code>, the result arrayOp performs a right join.
For both left and right arrays, only selected fields are included in the result arrayOp.
If no fields are selected, then all fields are treated as selected.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>right_join</span>(
  <span class='no'>right</span>,
  <span class='kw'>by.x</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>by.y</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>by</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>left_alias</span> <span class='kw'>=</span> <span class='st'>"_L"</span>,
  <span class='kw'>right_alias</span> <span class='kw'>=</span> <span class='st'>"_R"</span>,
  <span class='kw'>settings</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>right</code></dt><dd><p>An arrayOp instance</p></dd>

<dt><code>by.x</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>by.y</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>by</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'. If not NULL,
must be fields of both operands.</p></dd>

<dt><code>left_alias</code></dt><dd><p>Alias for left array to resolve potential conflicting fields in result</p></dd>

<dt><code>right_alias</code></dt><dd><p>Alias for right array to resolve potential conflicting fields in result</p></dd>

<dt><code>settings</code></dt><dd><p>A named list as join settings. E.g. <code><a href='https://rdrr.io/r/base/list.html'> list(algorithm = "'hash_replicate_right'")</a></code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-semi_join"></a></p><h3>Method <code>semi_join()</code></h3>
<p>Return an arrayOp instance with same schema as self and content cells that
match the cells of 'df_or_arrayop'.</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/filter-joins.html'>dplyr::semi_join</a></code>, the result has the same schema as the left
operand 'self' and with content filtered by 'df_or_arrayop'.</p>
<p>params <code>field_mapping</code>, <code>lower_bound</code> and <code>upper_bound</code>, if provided, must be named list,
where the.names are from the source array (i.e. self), and values are from
the right operand <code>df_or_arrayop</code></p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>semi_join</span>(
  <span class='no'>df_or_arrayop</span>,
  <span class='kw'>field_mapping</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>lower_bound</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>upper_bound</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>mode</span> <span class='kw'>=</span> <span class='st'>"auto"</span>,
  <span class='kw'>filter_threshold</span> <span class='kw'>=</span> <span class='fl'>200L</span>,
  <span class='kw'>upload_threshold</span> <span class='kw'>=</span> <span class='fl'>6000L</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>df_or_arrayop</code></dt><dd><p>An R data frame or arrayOp instance.</p></dd>

<dt><code>field_mapping</code></dt><dd><p>NULL or a named list of strings. Only applicable when
mode is 'cross_between' mode, ignored in other modes.</p></dd>

<dt><code>lower_bound</code></dt><dd><p>NULL or a named list of strings. Only applicable when
mode is 'filter' or 'cross_between'. Names of the list are fields of self,
and value strings are fields or columns of the <code>df_or_arrayop</code> which are
treated as lower bound to matching fields rather than exact match.In 'filter' mode, the self fields in lower_bound can be any numeric fields.
In 'cross_between' mode, the self fields in lower_bound must be array dimensions.</p></dd>

<dt><code>upper_bound</code></dt><dd><p>NULL or a named list of strings. Only applicable when
mode is 'filter' or 'cross_between'. Names of the list are fields of self,
and value strings are fields or columns of the <code>df_or_arrayop</code> which are
treated as upper bound to matching fields rather than exact match.In 'filter' mode, the self fields in upper_bound can be any numeric fields.
In 'cross_between' mode, the self fields in upper_bound must be array dimensions.</p></dd>

<dt><code>mode</code></dt><dd><p>String of 'filter', 'cross_between', 'index_lookup' or 'auto'</p></dd>

<dt><code>filter_threshold</code></dt><dd><p>A number below which the 'filter' mode is used
unless a mode other than 'auto' is provided.</p></dd>

<dt><code>upload_threshold</code></dt><dd><p>A number below which the 'df_or_arrayop' data frame
is compield into a build literal array; otherwise uploaded to scidb as a regular array.
Only applicable when 'df_or_arrayop' is an R data frame.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>An arrayOp instance</p>
<p><hr>
<a id="method-group_by"></a></p><h3>Method <code>group_by()</code></h3>
<p>Create a new arrayOp with 'group by' fields</p>
<p>The result arrayOp is identical to self except for the 'group_by' fields.
When called before <code>summarize</code> function, result arrayOp will be converted into <code>grouped_aggregate</code> operation.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>group_by</span>(<span class='no'>...</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>field names as strings or string vectors, which will be merged
into a single string vector with <code><a href='https://rdrr.io/r/base/c.html'>c(...)</a></code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>An arrayOp instance with group_by fields</p>
<p><hr>
<a id="method-summarize"></a></p><h3>Method <code>summarize()</code></h3>
<p>Create a new arrayOp with aggregated fields</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>summarize</span>(<span class='no'>...</span>, <span class='kw'>.dots</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>aggregation expressions in R syntax. Names of expressions are optional.
If provided, names will be the fields of result arrayOp; otherwise field
names are auto generated by scidb.
Same syntax as <code>...</code> in 'filter' and 'mutate' functions.</p></dd>

<dt><code>.dots</code></dt><dd><p>a list of aggregation expressions. Similar to '.dots' in
'mutate' and 'transmute'.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-set_auto_fields"></a></p><h3>Method <code>set_auto_fields()</code></h3>
<p>Create a new ArrayOp instance that has auto incremented fields and/or anti-collision fields according to a template arrayOp</p>
<p>If the dimension count, attribute count and data types match between the source(self) and target,
then no redimension will be performed, otherwise redimension on the source first.</p>
<p>Redimension mode requires all target fields exist on the source disregard of being attributes or dimensions.
Redimension mode does not check on whether source data types match the target because auto data conversion
occurs within scidb where necessary/applicable.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>set_auto_fields</span>(
  <span class='no'>target</span>,
  <span class='kw'>source_auto_increment</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>target_auto_increment</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>anti_collision_field</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>join_setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>source_anti_collision_dim_spec</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>target</code></dt><dd><p>A target ArrayOp the source data is written to.</p></dd>

<dt><code>source_auto_increment</code></dt><dd><p>A single named integer, a single string, or NULL.
Eg. c(z=0) for field 'z' in the source (ie. self) starting from 0;
or a single string 'z' equivalent to c(z=0). If NULL, assume it to be the
only dimension in self, normally from an artificial dimension of a build literal or unpack operation.</p></dd>

<dt><code>target_auto_increment</code></dt><dd><p>a named number vector or string vector or NULL.
where the name is a target field and value is the starting index.
E.g. c(aid=0, bid=1) means to set auto fields 'aid', 'bid' according to the target fields of the same name.
If 'target' doesn't have a cell, then default values start from 0 and 1 for aid and bid, respectively.
A string vector c("aid", "bid") is equvilant to c(aid=0, bid=0).
NULL means treat all missing fields (absent in self but present in target) as 0-based auto increment fields.
Here the <code>target_auto_increment</code> param only affects the initial load when the field is still null in the target array.</p></dd>

<dt><code>anti_collision_field</code></dt><dd><p>a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).</p></dd>

<dt><code>join_setting</code></dt><dd><p>NULL or a named list. When not NULL, it is converted
to settings for scidb <code>equi_join</code> operator, only applicable when
<code>anti_collision_field</code> is not NULL.</p></dd>

<dt><code>source_anti_collision_dim_spec</code></dt><dd><p>NULL or a string.
If NULL, the dimension spec for the anti-collision dimension in source
(self) is taken from self's schema.
In rare cases, we need to set the dimension spec to control the chunk size
in the 'redimension' operation, e.g. <code>source_anti_collision_dim_spec = "0:*:0:123456"</code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayop instance</p>
<p><hr>
<a id="method-update"></a></p><h3>Method <code><a href='https://rdrr.io/r/stats/update.html'>update()</a></code></h3>
<p>Update the target array with self's content</p>
<p>Similar behavior to scidb insert operator.
Require numbers of attributes and dimensions of self and target arrays match.
Field names are irrelevant.</p>
<p>This function only returns an arrayOp with the update operation AFL
encapsulated. No real action is performed in scidb until
<code>source$update(target)$execute()</code> is called.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'><a href='https://rdrr.io/r/stats/update.html'>update</a></span>(<span class='no'>target</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>target</code></dt><dd><p>An arrayOp instance where self's content is updated. Must be
a persistent array, since it is meanlingless to update an array operation.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp that encapsulates the update operation</p>
<p><hr>
<a id="method-overwrite"></a></p><h3>Method <code>overwrite()</code></h3>
<p>Overwrite the target array with self's content</p>
<p>Similar behavior to scidb store operator.
Require numbers of attributes and dimensions of self and target arrays match.
Field names are irrelevant.</p>
<p>This function only returns an arrayOp with the update operation AFL
encapsulated. No real action is performed in scidb until
<code>source$overwrite(target)$execute()</code> is called.</p>
<p>Warning: Target's content will be erased and filled with self's content.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>overwrite</span>(<span class='no'>target</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>target</code></dt><dd><p>An arrayOp instance where self's content is written to.
Must be a persitent array either preexist or does not exist in scidb.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp that encapsulates the overwrite operation</p>
<p><hr>
<a id="method-select"></a></p><h3>Method <code>select()</code></h3>
<p>Create a new ArrayOp instance with selected fields</p>
<p>NOTE: this does NOT change the to_afl output, but explicitly state which field(s) should be retained if used in
a parent operation that changes its schema, e.g. <code>inner_join</code>, <code>left_join</code>, <code>right_join</code> and <code>to_df</code>.</p>
<p>The <code>select</code>ed fields are passed on to derived ArrayOp instances.</p>
<p>In all join operations, if no field is explicitly <code>select</code>ed, then all fields are assumed be retained.
In <code>to_df</code>, if no field is explicitly <code>select</code>ed, only the attributes are retrieved as data frame columns.
In <code>to_df_all</code>, if no field is explicitly <code>select</code>ed, it is equivalent to select all dimensions and attributes.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>select</span>(<span class='no'>...</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>Which field(s) to retain.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp</p>
<p><hr>
<a id="method-to_df_all"></a></p><h3>Method <code>to_df_all()</code></h3>
<p>Download query result of self's AFL string with all self's fields.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_df_all</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An R data frame with columns from self's dimensions and
attributes if no fields are selcted, or the selcted fields.</p>
<p><hr>
<a id="method-to_df"></a></p><h3>Method <code>to_df()</code></h3>
<p>Download query result of self's AFL string with all self's attributes.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_df</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An R data frame with columns from self's attributes if no fields
are selected, or the selcted fields only.</p>
<p><hr>
<a id="method-execute"></a></p><h3>Method <code>execute()</code></h3>
<p>Execute the AFL string for pure side effect without result returned.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>execute</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>self</p>
<p><hr>
<a id="method-persist"></a></p><h3>Method <code>persist()</code></h3>
<p>Create an arrayOp instance by persisting self's AFL if self is an array
operation or return self if self is already a persistent array in scidb</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>persist</span>(<span class='kw'>save_array_name</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>.temp</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>, <span class='kw'>.gc</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>save_array_name</code></dt><dd><p>NULL or String. The array name to save self's AFL as, only applicable
if self is an array operation. If NULL, the array name is randomly generated.</p></dd>

<dt><code>.temp</code></dt><dd><p>Boolean, default FALSE. Whether to creaet a temporary scidb array.</p></dd>

<dt><code>.gc</code></dt><dd><p>Boolean, default TRUE. Whether to remove the persisted scidb array
once the encapsulating arrayOp goes out of scodb in R.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance or self</p>
<p><hr>
<a id="method-change_schema"></a></p><h3>Method <code>change_schema()</code></h3>
<p>Create a new ArrayOp instance whose schema is the same as the <code>template</code>.</p>
<p>This operation throws away any fields that do not exist in <code>template</code> while keeping the <code>self</code>'s data of the
matching fields.</p>
<p>Implemented by scidb <code>redimension</code> operator, but it allows for partial-fields match if <code>strict=F</code>.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>change_schema</span>(<span class='no'>template</span>, <span class='kw'>strict</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>.setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>template</code></dt><dd><p>an ArrayOp instance as the schema template.</p></dd>

<dt><code>strict</code></dt><dd><p>If TRUE(default), requires <code>self</code> has all the <code>template</code> fields.</p></dd>

<dt><code>.setting</code></dt><dd><p>a string vector, where each item will be appended to the redimension operand.
E.g. .setting = c('false', 'cells_per_chunk: 1234') ==&gt; redimension(source, template, false, cells_per_chunk: 1234)</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-drop_dims"></a></p><h3>Method <code>drop_dims()</code></h3>
<p>Create a new arrayOp by dropping dimensions of 'self'.</p>
<p>Use <code>mode = 'unpack'</code> to still keep an artificial dimension in result arrayOp.
The dimension is 0-based, auto-incremented up until <code>self$cell_count() - 1</code>.
'unpack' mode is useful in taking advantage of this artifical dimension to
auto populate other fields, e.g. in <code>set_auto_fields</code>.</p>
<p>Use <code>mode = 'flatten'</code> to return a scidb data frame which has no explicit dimensions.</p>
<p>Result arrayOp in both modes has attributes of self's attributes and dimensions.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>drop_dims</span>(
  <span class='kw'>mode</span> <span class='kw'>=</span> <span class='st'>"unpack"</span>,
  <span class='kw'>.chunk_size</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.unpack_dim</span> <span class='kw'>=</span> <span class='no'>dbutils</span>$<span class='fu'>random_field_name</span>()
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>mode</code></dt><dd><p>String 'unpack' (default) or 'flatten'.</p></dd>

<dt><code>.chunk_size</code></dt><dd><p>NULL or an integer. Converted to the 'chunk_size' param
in 'unpack' mode; and 'cells_per_chunk' in 'flatten' mode.</p></dd>

<dt><code>.unpack_dim</code></dt><dd><p>NULL (default) or string as the dimension if 'unpack'
mode is chosen. NULL defaults to a random field name.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-sync_schema"></a></p><h3>Method <code>sync_schema()</code></h3>
<p>Create a new arrayOp with actual schema from SciDB or 'self' if
<code>self$is_schema_from_scidb == T</code>.</p>
<p>Useful in confirmming the schema of complex array operations.
If the array schema is already retrieved from SciDB, then just return self.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>sync_schema</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An arrayOp instance</p>
<p><hr>
<a id="method-spawn"></a></p><h3>Method <code>spawn()</code></h3>
<p>Create a new ArrayOp instance using 'self' as a template</p>
<p>This function is mainly for array schema string generation when
we want to rename, add, and/or exclude certain fields of self, but still
keep other unspecified fields unchanged.</p>
<p>Data types and dimension specs of existing fields are inherited from 'self' unless provided explicitly.
New field data types default to NAs unless provided explicitly.</p>
<p>This function is normally used internally for arrayOp generation.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>spawn</span>(
  <span class='kw'>afl_str</span> <span class='kw'>=</span> <span class='st'>"spawned array_op (as template only)"</span>,
  <span class='kw'>renamed</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>added</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>excluded</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>dtypes</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>dim_specs</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>afl_str</code></dt><dd><p>An AFL expression. In case of using the spawned result as
a schema template only, the afl_str does not need to be provided. Otherwise,
it should conform with the actual resultant arrayOp instance, which is very rare.</p></dd>

<dt><code>renamed</code></dt><dd><p>A list of renamed fields where names are old fields and values are new field names.</p></dd>

<dt><code>added</code></dt><dd><p>New fields added to result arrayOp. String vector or NULL.</p></dd>

<dt><code>excluded</code></dt><dd><p>Fields excluded from <code>self</code>. String vector or NULL.</p></dd>

<dt><code>dtypes</code></dt><dd><p>NULL or a named list of data types for fields of the result arrayOp,
where names are field names, values (strings) are data types.</p></dd>

<dt><code>dim_specs</code></dt><dd><p>NULL or a named list of array dimension specs,
where names are dimension names, values (strings) are dimension specs in scidb format.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-to_afl"></a></p><h3>Method <code>to_afl()</code></h3>
<p>AFL string encapsulated by of the self ArrayOp</p>
<p>AFL can be either an scidb array name or array operation(s) on array(s).</p>
<p>The ArrayOp instance may have 'selected' fields but they are not reflected in the result.
'selected' fields are not reflected here, but determines which fields are retained in <code>to_df()</code> calls.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_afl</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>an AFL expression string</p>
<p><hr>
<a id="method-to_schema_str"></a></p><h3>Method <code>to_schema_str()</code></h3>
<p>Return a schema representation of the ArrayOp <code>&lt;attr1:type1 [, attr2:type2 ...]&gt; [dim1 [;dim2]]</code></p>
<p>Unless <code>sync_schema()</code> is called, the schema may be inferred locally in R to save round trips between R and SciDB server.
SciDB data frames have hidden dimensions that start with <code>$</code></p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_schema_str</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>SciDB schema string</p>
<p><hr>
<a id="method-limit"></a></p><h3>Method <code>limit()</code></h3>
<p>Create a new arrayOp that encapsulate AFL for the first <code>n</code> cells of 'self'</p>
<p>We still need to append a <code>to_df</code> call to download the result as data frame.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>limit</span>(<span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>5</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>n</code></dt><dd><p>How many cells to take</p></dd>

<dt><code>skip</code></dt><dd><p>How many rows to skip before taking</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new ArrayOp instance</p>
<p><hr>
<a id="method-cell_count"></a></p><h3>Method <code>cell_count()</code></h3>
<p>Return the number of cells of 'self'</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>cell_count</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>A number of cells if the AFL that 'self' encapsulates is run.</p>
<p><hr>
<a id="method-summarize_array"></a></p><h3>Method <code>summarize_array()</code></h3>
<p>Return a data frame of the summary of the 'self' array</p>
<p>Implemented by scidb 'summarize' operator</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>summarize_array</span>(<span class='kw'>by_attribute</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>, <span class='kw'>by_instance</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>by_attribute</code></dt><dd><p>Summarize by array attributes</p></dd>

<dt><code>by_instance</code></dt><dd><p>Summarize by array scidb instances</p></dd>

<dt><code>return</code></dt><dd><p>A data frame of the 'self' array summary</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-versions"></a></p><h3>Method <code>versions()</code></h3>
<p>Return a data frame of all self's versions</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>versions</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An R data frame with columns: version_id and timestamp</p>
<p><hr>
<a id="method-get_version_snapshot"></a></p><h3>Method <code>get_version_snapshot()</code></h3>
<p>Get an arrayOp instance that encapsulates a version snapshot of a persistent
scidb array</p>
<p>The function does not perform version check in scidb. It only construct
an arrayOp locally to represent a specific version. If a non-existent
version_id is later used in scidb related operations, an error will be
thrown by SciDB.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>get_version_snapshot</span>(<span class='no'>version_id</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>version_id</code></dt><dd><p>A number of the array version_id</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>An arrayOp instance with the same schema as self</p>
<p><hr>
<a id="method-is_persistent"></a></p><h3>Method <code>is_persistent()</code></h3>
<p>Returns whether the current arraOp instance encapsulates a persistent scidb
array namne that may or may not exist on the scidb server</p>
<p>No checking with scidb server is performed. Only validate the arrayOp's AFL
with regex and see if it matches an array name. E.g. "myNamespace.myArray"
or "myArrayInPublicNamespace".</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>is_persistent</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>TRUE or FALSE</p>
<p><hr>
<a id="method-exists_persistent_array"></a></p><h3>Method <code>exists_persistent_array()</code></h3>
<p>Returns whether the current arraOp instance encapsulates a persistent scidb
array that exists on the scidb server</p>
<p>If current arrayOp encapsulates an array operation, then it returns FALSE
without checking with scidb server.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>exists_persistent_array</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>TRUE or FALSE</p>
<p><hr>
<a id="method-array_meta_data"></a></p><h3>Method <code>array_meta_data()</code></h3>
<p>Download the array meta as an R data frame</p>
<p>The array metadata is retrieved from executing the scidb 'show' operator
in the array namespace and match for the current array name.
Array metadata include fields: "name", "uaid", "aid", "schema", "availability", "temporary",  "namespace", "distribution", "etcomp"</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>array_meta_data</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An R data frame</p>
<p><hr>
<a id="method-remove_versions"></a></p><h3>Method <code>remove_versions()</code></h3>
<p>Remove array versions of self</p>
<p>Only applicable to persistent arrays.
<strong>Warning</strong>: This function will be executed effectively in scidb without
extra 'execute()' and cannot be undone.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>remove_versions</span>(<span class='kw'>version_id</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>version_id</code></dt><dd><p>NULL or a number. When set to NULL, all array versions
are removed except for the latest one. When set to an number, must be
a valid version_id of self, in which case all versions up to the 'version_id'
are removed.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>NULL</p>
<p><hr>
<a id="method-remove_array"></a></p><h3>Method <code>remove_array()</code></h3>
<p>Remove array versions of self</p>
<p>Only applicable to persistent arrays.
<strong>Warning</strong>: This function will be executed effectively in scidb without
extra 'execute()' and cannot be undone.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>remove_array</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>NULL</p>
<p><hr>
<a id="method-finalize"></a></p><h3>Method <code>finalize()</code></h3>
<p>A finalize function executed when the 'self' instance is garbage collected in R</p>
<p>If an arrayOp is marked as .gc = T, then it will be removed from scidb
when this function is executed.</p>
<p>We don't normally call this function except in testing.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>finalize</span>()</pre><p></div></p>




  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by  Paradigm4.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.9000.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>



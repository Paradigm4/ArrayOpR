<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Base class of all ArrayOp classes — ArrayOpBase • arrayop</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Base class of all ArrayOp classes — ArrayOpBase" />
<meta property="og:description" content="ArrayOp classes denote scidb array operations and operands, hence the name." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">arrayop</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/arrayop.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/semi_join.html">Semi Join</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/Paradigm4/ArrayOpR/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Base class of all ArrayOp classes</h1>
    <small class="dont-index">Source: <a href='https://github.com/Paradigm4/ArrayOpR/blob/master/R/array_op_base.R'><code>R/array_op_base.R</code></a></small>
    <div class="hidden name"><code>ArrayOpBase.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>ArrayOp classes denote scidb array operations and operands, hence the name.</p>
    </div>



    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>One operation consists of an scidb operator and 1..* operands, of which the result can be used as an operand
in another operation. Operands and Opreration results can all be denoted by ArrayOp.</p>
    <h2 class="hasAnchor" id="active-bindings"><a class="anchor" href="#active-bindings"></a>Active bindings</h2>

    <p><div class="r6-active-bindings"></p><dl>
<dt><code>dims</code></dt><dd><p>Dimension names</p></dd>

<dt><code>attrs</code></dt><dd><p>Attribute names</p></dd>

<dt><code>selected</code></dt><dd><p>Selected dimension and/or attribute names</p></dd>

<dt><code>dtypes</code></dt><dd><p>A named list, where key is dim/attr name and value is respective SciDB data type as string</p></dd>

<dt><code>raw_dtypes</code></dt><dd><p>A named list, where key is dim/attr name and value is first part of respective SciDB data type as string</p></dd>

<dt><code>dims_n_attrs</code></dt><dd><p>Dimension and attribute names</p></dd>

<dt><code>attrs_n_dims</code></dt><dd><p>Attribute and dimension names</p></dd>

<dt><code>is_schema_from_scidb</code></dt><dd><p>If the array schema is retrieved from SciDB or inferred locally in R</p></dd>

<dt><code>is_scidb_data_frame</code></dt><dd><p>Whether current array_op is a regular array or
SciDB data frame (array with hidden dimensions; not to be confused with R data frames)</p></dd>

<dt><code>.private</code></dt><dd><p>For internal testing only. Do not access this field to avoid unintended consequences!!!</p></dd>

</dl><p></div></p>
    <h2 class="hasAnchor" id="methods"><a class="anchor" href="#methods"></a>Methods</h2>

    
<h3>Public methods</h3>

<ul>
<li><p><a href='#method-new'><code>ArrayOpBase$new()</code></a></p></li>
<li><p><a href='#method-filter'><code>ArrayOpBase$filter()</code></a></p></li>
<li><p><a href='#method-select'><code>ArrayOpBase$select()</code></a></p></li>
<li><p><a href='#method-change_schema'><code>ArrayOpBase$change_schema()</code></a></p></li>
<li><p><a href='#method-set_auto_fields'><code>ArrayOpBase$set_auto_fields()</code></a></p></li>
<li><p><a href='#method-mutate'><code>ArrayOpBase$mutate()</code></a></p></li>
<li><p><a href='#method-transmute'><code>ArrayOpBase$transmute()</code></a></p></li>
<li><p><a href='#method-mutate_by'><code>ArrayOpBase$mutate_by()</code></a></p></li>
<li><p><a href='#method-drop_dims'><code>ArrayOpBase$drop_dims()</code></a></p></li>
<li><p><a href='#method-update'><code>ArrayOpBase$update()</code></a></p></li>
<li><p><a href='#method-overwrite'><code>ArrayOpBase$overwrite()</code></a></p></li>
<li><p><a href='#method-spawn'><code>ArrayOpBase$spawn()</code></a></p></li>
<li><p><a href='#method-limit'><code>ArrayOpBase$limit()</code></a></p></li>
<li><p><a href='#method-cell_count'><code>ArrayOpBase$cell_count()</code></a></p></li>
<li><p><a href='#method-summarize_array'><code>ArrayOpBase$summarize_array()</code></a></p></li>
<li><p><a href='#method-sync_schema'><code>ArrayOpBase$sync_schema()</code></a></p></li>
<li><p><a href='#method-group_by'><code>ArrayOpBase$group_by()</code></a></p></li>
<li><p><a href='#method-summarize'><code>ArrayOpBase$summarize()</code></a></p></li>
<li><p><a href='#method-to_afl'><code>ArrayOpBase$to_afl()</code></a></p></li>
<li><p><a href='#method-to_schema_str'><code>ArrayOpBase$to_schema_str()</code></a></p></li>
<li><p><a href='#method-to_df_all'><code>ArrayOpBase$to_df_all()</code></a></p></li>
<li><p><a href='#method-to_df'><code>ArrayOpBase$to_df()</code></a></p></li>
<li><p><a href='#method-execute'><code>ArrayOpBase$execute()</code></a></p></li>
<li><p><a href='#method-versions'><code>ArrayOpBase$versions()</code></a></p></li>
<li><p><a href='#method-remove_versions'><code>ArrayOpBase$remove_versions()</code></a></p></li>
<li><p><a href='#method-remove_array'><code>ArrayOpBase$remove_array()</code></a></p></li>
<li><p><a href='#method-inner_join'><code>ArrayOpBase$inner_join()</code></a></p></li>
<li><p><a href='#method-left_join'><code>ArrayOpBase$left_join()</code></a></p></li>
<li><p><a href='#method-right_join'><code>ArrayOpBase$right_join()</code></a></p></li>
<li><p><a href='#method-semi_join'><code>ArrayOpBase$semi_join()</code></a></p></li>
<li><p><a href='#method-persist'><code>ArrayOpBase$persist()</code></a></p></li>
<li><p><a href='#method-is_persistent'><code>ArrayOpBase$is_persistent()</code></a></p></li>
<li><p><a href='#method-exists_persistent_array'><code>ArrayOpBase$exists_persistent_array()</code></a></p></li>
<li><p><a href='#method-array_meta_data'><code>ArrayOpBase$array_meta_data()</code></a></p></li>
<li><p><a href='#method-finalize'><code>ArrayOpBase$finalize()</code></a></p></li>
</ul>
<p><hr>
<a id="method-new"></a></p><h3>Method <code>new()</code></h3>
<p>Return ArrayOp field types as a list</p>

<p>Get dimension specifications as a list</p>
<p>A dimension spec str is formatted as "lower bound : upper bound : overlap : chunk_length",
as seen in scidb <code>show(array_name)</code> operator.
All dimensions' data types are int64, as returned by <code>get_field_types</code> function.</p>

<p>Generate afl for ArrayOp used in a join context (equi_join).</p>

<p>Create a new ArrayOp instance by joining with another ArrayOp</p>
<p>Currently implemented with scidb <code>equi_join</code> operator.</p>

<p>Disambiguate selected fields of join</p>
<p>If no name clashes between selected fields of both operands,
nothing changes.
Otherwise, add suffix to duplicated fields for each operand.
E.g. if a field named 'value' exists on both operands and is retained,
it will be renamed as 'value_left' and 'value_right' if left_alias and right_alias
are '_left' and '_right', respectively.</p>

<p>Create a new ArrayOp by matching a template against a source (self).</p>
<p>The result has the same schema with the source.
All fields in the template are compared to their matching source fields by equality, except for thos in
lower_bound/upper_bound which will be used as a range <code>[lower_bound, upper_bound]</code>.</p>

<p>Return a new arrayOp instance with the same version as <code>self</code></p>
<p>Work in sub-class without requiring class names or constructor function.</p>

<p>Create a new ArrayOp instance from 'build'ing a data.frame</p>
<p>All matching fields are built as attributes of the result ArrayOp.
Build operator accepts compound attribute types, so the result may have something like "build(&lt;aa:string not null, ...)"</p>

<p>Create a new ArrayOp instance by loading a file and checking it against an ArrayOp template (self).</p>
<p>The ArrayOp instance where this function is called from serves as a template. By defulat, it assumes file
column headers match the template's dims and attrs; otherwise an explicit file_headers can be provided and will
be used to match the template's schema.</p>

<p>Create a new ArrayOp instance that with added auto incremented fields</p>

<p>Create a new ArrayOp instance that has an anti-collision field set according to a template arrayOp</p>
<p>The source (self) operand should have N fields given the target has N+1 dimensions. The one missing field is
treated as the anti-collision field.</p>

<p>Return AFL suitable for retrieving data.frame.</p>
<p>scidb::iquery has a param <code>only_attributes</code>, which, if set TRUE, will effectively drop all dims.</p>

<p>Returns AFL when self used as an operand in another parent operation.</p>
<p>By default, 1. dimensions are not dropped in parent operation; 2. no intent to select fields</p>

<p>Base class initialize function, to be called in sub-class internally.</p>
<p>Always use <code>ScidbConnection</code> to get array_op instances.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>new</span>(
  <span class='no'>raw_afl</span>,
  <span class='kw'>dims</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/character.html'>as.character</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>()),
  <span class='kw'>attrs</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/character.html'>as.character</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>()),
  <span class='kw'>dtypes</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(),
  <span class='kw'>dim_specs</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(),
  <span class='no'>...</span>,
  <span class='no'>meta_list</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>dims</code></dt><dd><p>A string vector used as dimension names</p></dd>

<dt><code>attrs</code></dt><dd><p>A string vector used as attribute names</p></dd>

<dt><code>dtypes</code></dt><dd><p>A named list of strings, where names are attribute names and
values are full scidb data types.
E.g. <code>dtypes = list(field_str = "string NOT NULL", field_int32 = "int32")</code></p></dd>

<dt><code>dim_specs</code></dt><dd><p>A named list of string, where names are dimension names
and values are dimension specs.
E.g. <code>dim_sepcs = list(da = "0:*:0:*", chrom = "1:24:0:1")</code>.</p></dd>

<dt><code>...</code></dt><dd><p>The samme params with Repo$ArrayOp(...)</p></dd>

<dt><code>...</code></dt><dd><p>A  named list of metadata items, where names are used as keys
in <code>private$set_meta</code> and <code>private$get_meta</code> functions.</p></dd>

<dt><code>meta_list</code></dt><dd><p>A list that stores ArrayOp meta data, e.g. field types
If provided, other regular parms are not allowed.</p></dd>

<dt><code>field_names</code></dt><dd><p>R character. If NULL, defaults to <code>self$dims_n_attrs</code>, ie. dimensions and attributes.</p></dd>

<dt><code>.raw</code></dt><dd><p>Default FALSE, full data types are returned; if set TRUE, only the raw data types are returned
(raw data types are string, int32, int64, bool, etc, without scidb attribute specs such as: string compression 'zlib')</p></dd>

<dt><code>dim_names</code></dt><dd><p>Default NULL equals all dimensions.</p></dd>

<dt><code>keyFileds</code></dt><dd><p>Field names as join keys</p></dd>

<dt><code>keep_dimensiosn</code></dt><dd><p>If <code>keep_dimensions</code> is specified in scidb <code>equi_join</code> operator</p></dd>

<dt><code>right</code></dt><dd><p>The other ArrayOp instance to join with.</p></dd>

<dt><code>on_left</code></dt><dd><p>R character vector. Join keys from the left (self).</p></dd>

<dt><code>on_right</code></dt><dd><p>R character vector. Join keys from the <code>right</code>. Must be of the same length as <code>on_left</code></p></dd>

<dt><code>on_both</code></dt><dd><p>Join keys on both operand.</p></dd>

<dt><code>settings</code></dt><dd><p><code>equi_join</code> settings, a named list where both key and values are strings.</p></dd>

<dt><code>.dim_mode</code></dt><dd><p>How to reshape the resultant ArrayOp. Same meaning as in <code>ArrayOp$reshape</code> function.
By default, dim_mode = 'keep', the artificial dimensions, namely <code>instance_id</code> and <code>value_no</code> from <code>equi_join</code>
are retained. If set to 'drop', the artificial dimensions will be removed. See <code>ArrayOp$reshape</code> for more details.</p></dd>

<dt><code>.artificial_field</code></dt><dd><p>As in <code>ArrayOp$reshape</code>, it defaults to a random field name. It can be safely ignored in
client code. It exists only for test purposes.</p></dd>

<dt><code>template</code></dt><dd><p>A data.frame or ArrayOp used to reduce the number of source cells without changing its schema</p></dd>

<dt><code>op_mode</code></dt><dd><p>'filter', 'cross_between'</p></dd>

<dt><code>lower_bound</code></dt><dd><p>Field names as lower bounds.</p></dd>

<dt><code>upper_bound</code></dt><dd><p>Field names as upper bounds.</p></dd>

<dt><code>field_mapping</code></dt><dd><p>A named list where name is source field name and value is template field name.
Default NULL: fields are mapped between template and source by field names only.
If there is mapping fields in the template which are intended for lower or upper bound,
provide an empty list or a list with matching fields</p></dd>

<dt><code>df</code></dt><dd><p>a data.frame, where all column names must all validate template fields.</p></dd>

<dt><code>artificial_field</code></dt><dd><p>A field name used as the artificial dimension name in <code>build</code> scidb operator
By default, a random string is generated, and the dimension starts from 0.
A customized dimension can be provided e.g. <code>z=42:*</code> or <code>z=0:*:0:1000</code>.</p></dd>

<dt><code>filepath</code></dt><dd><p>A single file path</p></dd>

<dt><code>aio_settings</code></dt><dd><p>Customized settings of aio_input</p></dd>

<dt><code>field_conversion</code></dt><dd><p>If NULL (default), use template's field type to convert aio_input attributes; Or provide
a list for customized field conversion</p></dd>

<dt><code>file_headers</code></dt><dd><p>Column headers of the input file regardless of whether there is a header line in the file.
Default NULL assumes file headers match self$dims_n_attrs. If the headers order are different or there are
columns to skip, please provide a string vector, in which case only columns with matching template field are
loaded. Names of the unmatching column headers are irrelevant.</p></dd>

<dt><code>field_vec</code></dt><dd><p>A named string vector</p></dd>

<dt><code>reference</code></dt><dd><p>ArrayOp instance to draw existing max id from</p></dd>

<dt><code>source_field</code></dt><dd><p></p></dd>

<dt><code>ref_field</code></dt><dd><p></p></dd>

<dt><code>source_start</code></dt><dd><p></p></dd>

<dt><code>ref_start</code></dt><dd><p></p></dd>

<dt><code>new_field</code></dt><dd><p></p></dd>

<dt><code>target</code></dt><dd><p>A target arrayOp that the source draws anti-collision dimension from.</p></dd>

<dt><code>anti_collision_field</code></dt><dd><p>a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).</p></dd>

<dt><code>drop_dims</code></dt><dd><p>Whether self's dimensions are dropped when generating AFL for data.frame conversion</p></dd>

<dt><code>drop_dims</code></dt><dd><p>Whether self dimensions will be dropped in parent operations</p></dd>

<dt><code>selected_fields</code></dt><dd><p>which fields are selected no matter what the parent operation is.
If NULL, self fields will pass on by default depending on the parent operation.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>a named list where keys are field names,
and values are scidb data types (single word or multiple words).</p>
<p>Throw an error if field_names are not all valid.</p>
<p><hr>
<a id="method-filter"></a></p><h3>Method <code><a href='https://rdrr.io/r/stats/filter.html'>filter()</a></code></h3>
<p>Create a new ArrayOp instance with filter expressions</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/filter.html'>dplyr::filter</a></code>, fields are not quoted.</p>
<p>Operators for any type of fields include <code>==</code>, <code>!=</code>,
<code>%in%</code>, <code>%not_in%</code>.
To test whether a field is null, use unary operators: <code>is_null</code>, <code>not_null</code>.</p>
<p>Special binary operators for string fields include:
<code>%contains%</code>, <code>%starts_with%</code>, <code>%ends_with%</code>, <code>%like%</code>, where
only <code>%like%</code> takes a regular expression and other operators escape any special
characters in the right operand.</p>
<p>Operators for numeric fields include: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'><a href='https://rdrr.io/r/stats/filter.html'>filter</a></span>(
  <span class='no'>...</span>,
  <span class='kw'>.expr</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.validate_fields</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
  <span class='kw'>.regex_func</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span>(<span class='st'>"arrayop.regex_func"</span>, <span class='kw'>default</span> <span class='kw'>=</span> <span class='st'>"regex"</span>),
  <span class='kw'>.ignore_case</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span>(<span class='st'>"arrayop.ignore_case"</span>, <span class='kw'>default</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>Filter expression(s) in R syntax.
These expression(s) are not evaluated in R but first captured then converted to scidb expressions with appropriate syntax.</p></dd>

<dt><code>.expr</code></dt><dd><p>A single R expression, or a list of R exprs, or NULL.
If provided, <code>...</code> is ignored. Mutiple exprs are joined by 'and'.
This param is useful when we want to pass an already captured R expression.</p></dd>

<dt><code>regex_func</code></dt><dd><p>A string of regex function implementation, default 'regex'.
Due to scidb compatiblity issue with its dependencies, the regex function from boost library may not be available
Currently supported options include 'rsub', and 'regex'</p></dd>

<dt><code>ignore_case</code></dt><dd><p>A Boolean, default TRUE. If TRUE, ignore case in string match patterns.
Otherwise, perform case-sensitive regex matches.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp</p>
<p><hr>
<a id="method-select"></a></p><h3>Method <code>select()</code></h3>
<p>Create a new ArrayOp instance with selected fields</p>
<p>NOTE: this does NOT change the to_afl output, but explicitly state which field(s) should be retained if used in
a parent operation that changes its schema, e.g. <code>inner_join</code>, <code>left_join</code>, <code>right_join</code> and <code>to_df</code>.</p>
<p>The <code>select</code>ed fields are passed on to derived ArrayOp instances.</p>
<p>In all join operations, if no field is explicitly <code>select</code>ed, then all fields are assumed be retained.
In <code>to_df</code>, if no field is explicitly <code>select</code>ed, only the attributes are retrieved as data frame columns.
In <code>to_df_all</code>, if no field is explicitly <code>select</code>ed, it is equivalent to select all dimensions and attributes.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>select</span>(<span class='no'>...</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>Which field(s) to retain.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp</p>
<p><hr>
<a id="method-change_schema"></a></p><h3>Method <code>change_schema()</code></h3>
<p>Create a new ArrayOp instance whose schema is the same as the <code>template</code>.</p>
<p>This operation throws away any fields that do not exist in <code>template</code> while keeping the <code>self</code>'s data of the
matching fields.</p>
<p>Implemented by scidb <code>redimension</code> operator, but it allows for partial-fields match if <code>strict=F</code>.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>change_schema</span>(<span class='no'>template</span>, <span class='kw'>strict</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>.setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>template</code></dt><dd><p>an ArrayOp instance as the schema template.</p></dd>

<dt><code>strict</code></dt><dd><p>If TRUE(default), requires <code>self</code> has all the <code>template</code> fields.</p></dd>

<dt><code>.setting</code></dt><dd><p>a string vector, where each item will be appended to the redimension operand.
E.g. .setting = c('false', 'cells_per_chunk: 1234') ==&gt; redimension(source, template, false, cells_per_chunk: 1234)</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-set_auto_fields"></a></p><h3>Method <code>set_auto_fields()</code></h3>
<p>Create a new ArrayOp instance that has auto incremented fields and/or anti-collision fields according to a template arrayOp</p>
<p>If the dimension count, attribute count and data types match between the source(self) and target,
then no redimension will be performed, otherwise redimension on the source first.</p>
<p>Redimension mode requires all target fields exist on the source disregard of being attributes or dimensions.
Redimension mode does not check on whether source data types match the target because auto data conversion
occurs within scidb where necessary/applicable.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>set_auto_fields</span>(
  <span class='no'>target</span>,
  <span class='kw'>source_auto_increment</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>target_auto_increment</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>anti_collision_field</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>join_setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>source_anti_collision_dim_spec</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>target</code></dt><dd><p>A target ArrayOp the source data is written to.</p></dd>

<dt><code>source_auto_increment</code></dt><dd><p>A single named integer, a single string, or NULL.
Eg. c(z=0) for field 'z' in the source (ie. self) starting from 0;
or a single string 'z' equivalent to c(z=0). If NULL, assume it to be the
only dimension in self, normally from an artificial dimension of a build literal or unpack operation.</p></dd>

<dt><code>target_auto_increment</code></dt><dd><p>a named number vector or string vector or NULL.
where the name is a target field and value is the starting index.
E.g. c(aid=0, bid=1) means to set auto fields 'aid', 'bid' according to the target fields of the same name.
If 'target' doesn't have a cell, then default values start from 0 and 1 for aid and bid, respectively.
A string vector c("aid", "bid") is equvilant to c(aid=0, bid=0).
NULL means treat all missing fields (absent in self but present in target) as 0-based auto increment fields.
Here the <code>target_auto_increment</code> param only affects the initial load when the field is still null in the target array.</p></dd>

<dt><code>anti_collision_field</code></dt><dd><p>a target dimension name which exsits only to resolve cell collision
(ie. cells with the same dimension coordinate).</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayop instance</p>
<p><hr>
<a id="method-mutate"></a></p><h3>Method <code>mutate()</code></h3>
<p>Create a new ArrayOp instance with mutated fields</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate.html'>dplyr::mutate</a></code>, fields of source (self) can be removed or added to the result arrayOp
Any field that are not in the mutate expressions remain unchanged.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>mutate</span>(<span class='no'>...</span>, <span class='kw'>.dots</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>.sync_schema</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>Named R expressions. Names are field names in the result arrayOp and must not be empty.
Set field = NULL to remove existing fields. E.g. <code>abcd = NULL, def = def</code> removes
field 'abcd' and keep field 'def'.Values are R expressions similar to the <code>filter</code> method.
E.g. <code>a = b + 2, name = first + "-" + last, chrom = if(chrom == 'x') 23 else if(chrom == 'y') 24 else chrom</code></p></dd>

<dt><code>.dots</code></dt><dd><p>A named list of R expressions or NULL. If provided,
the <code>...</code> param is ignored. Useful when an a list of mutation expressions is already
created and can be passed around.</p></dd>

<dt><code>.sync_schema</code></dt><dd><p>Whether to get the exact schema from scidb. Default
TRUE will cause a scidb query to get the schema. Set to FALSE to avoid schema checking.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>a new ArrayOp instance</p>
<p><hr>
<a id="method-transmute"></a></p><h3>Method <code>transmute()</code></h3>
<p>Create a new ArrayOp instance with mutated fields</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate.html'>dplyr::transmute</a></code>, only listed fields are retained in the result arrayOp
NOTE: Any field that are not in the mutate expressions will be discarded.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>transmute</span>(<span class='no'>...</span>, <span class='kw'>.dots</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>.sync_schema</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>R expressions. Names are optional.
For each named expression, the name is used as field name in the result arrayOp.
Unnamed expressions must be existing field names, unquoted, which result in unchanged source fields of self.Values are R expressions similar to the <code>filter</code> method.
E.g. <code>a = b + 2, name = first + "-" + last, chrom = if(chrom == 'x') 23 else if(chrom == 'y') 24 else chrom</code></p></dd>

<dt><code>.dots</code></dt><dd><p>A named list of R expressions or NULL. If provided,
the <code>...</code> param is ignored. Useful when an a list of mutation expressions is already
created and can be passed around.</p></dd>

<dt><code>.sync_schema</code></dt><dd><p>Whether to get the exact schema from scidb. Default
TRUE will cause a scidb query to get the schema. Set to FALSE to avoid schema checking.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>a new ArrayOp instance</p>
<p><hr>
<a id="method-mutate_by"></a></p><h3>Method <code>mutate_by()</code></h3>
<p>Create a ArrayOp instance with the same schema of self, but different cells
from 'data_array' for the 'updated_fields'.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>mutate_by</span>(
  <span class='no'>data_array</span>,
  <span class='kw'>keys</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>updated_fields</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.redimension_setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.join_setting</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>data_array</code></dt><dd><p>An ArrayOp instance that have at least two overlapping fields with self.</p></dd>

<dt><code>keys</code></dt><dd><p>Field names in both self and data_array. Cell content of these
fields are from the 'self' arrayOp rather than 'data_array'.</p></dd>

<dt><code>updated_fields</code></dt><dd><p>Field names in both self and data_array. Cell content
of these fields are from the 'data_array', NOT 'self'.</p></dd>

<dt><code>.redimension_setting</code></dt><dd><p>A list of strings used as the settings of scidb
'redimension' operator. Only applicable when a 'redimension' is needed.</p></dd>

<dt><code>.join_setting</code></dt><dd><p>A list of strings used as the settings of scidb
'join' operator. Only applicable when a 'join' is needed.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp with the same schema as self</p>
<p><hr>
<a id="method-drop_dims"></a></p><h3>Method <code>drop_dims()</code></h3>
<p>Create a new arrayOp by dropping dimensions of 'self'.</p>
<p>Use <code>mode = 'unpack'</code> to still keep an artificial dimension in result arrayOp.
The dimension is 0-based, auto-incremented up until <code>self$cell_count() - 1</code>.
'unpack' mode is useful in taking advantage of this artifical dimension to
auto populate other fields, e.g. in <code>set_auto_fields</code>.</p>
<p>Use <code>mode = 'flatten'</code> to return a scidb data frame which has no explicit dimensions.</p>
<p>Result arrayOp in both modes has attributes of self's attributes and dimensions.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>drop_dims</span>(
  <span class='kw'>mode</span> <span class='kw'>=</span> <span class='st'>"unpack"</span>,
  <span class='kw'>.chunk_size</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>.unpack_dim</span> <span class='kw'>=</span> <span class='no'>dbutils</span>$<span class='fu'>random_field_name</span>()
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>mode</code></dt><dd><p>String 'unpack' (default) or 'flatten'.</p></dd>

<dt><code>.chunk_size</code></dt><dd><p>NULL or an integer. Converted to the 'chunk_size' param
in 'unpack' mode; and 'cells_per_chunk' in 'flatten' mode.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-update"></a></p><h3>Method <code><a href='https://rdrr.io/r/stats/update.html'>update()</a></code></h3>
<p>Update the target array with self's content</p>
<p>Similar behavior to scidb insert operator.
Require numbers of attributes and dimensions of self and target arrays match.
Field names are irrelevant.</p>
<p>This function only returns an arrayOp with the update operation AFL
encapsulated. No real action is performed in scidb until
<code>source$update(target)$execute()</code> is called.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'><a href='https://rdrr.io/r/stats/update.html'>update</a></span>(<span class='no'>target</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>target</code></dt><dd><p>An arrayOp instance where self's content is updated. Must be
a persistent array, since it is meanlingless to update an array operation.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp that encapsulates the update operation</p>
<p><hr>
<a id="method-overwrite"></a></p><h3>Method <code>overwrite()</code></h3>
<p>Overwrite the target array with self's content</p>
<p>Similar behavior to scidb store operator.
Require numbers of attributes and dimensions of self and target arrays match.
Field names are irrelevant.</p>
<p>This function only returns an arrayOp with the update operation AFL
encapsulated. No real action is performed in scidb until
<code>source$overwrite(target)$execute()</code> is called.</p>
<p>Warning: Target's content will be erased and filled with self's content.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>overwrite</span>(<span class='no'>target</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>target</code></dt><dd><p>An arrayOp instance where self's content is written to.
Must be a persitent array either preexist or does not exist in scidb.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp that encapsulates the overwrite operation</p>
<p><hr>
<a id="method-spawn"></a></p><h3>Method <code>spawn()</code></h3>
<p>Create a new ArrayOp instance using 'self' as a template</p>
<p>This function is mainly for array schema string generation when
we want to rename, add, and/or exclude certain fields of self, but still
keep other unspecified fields unchanged.</p>
<p>Data types and dimension specs of existing fields are inherited from 'self' unless provided explicitly.
New field data types default to NAs unless provided explicitly.</p>
<p>This function is normally used internally for arrayOp generation.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>spawn</span>(
  <span class='kw'>afl_str</span> <span class='kw'>=</span> <span class='st'>"spawned array_op (as template only)"</span>,
  <span class='kw'>renamed</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>added</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>excluded</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>dtypes</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>dim_specs</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>afl_str</code></dt><dd><p>An AFL expression. In case of using the spawned result as
a schema template only, the afl_str does not need to be provided. Otherwise,
it should conform with the actual resultant arrayOp instance, which is very rare.</p></dd>

<dt><code>renamed</code></dt><dd><p>A list of renamed fields where names are old fields and values are new field names.</p></dd>

<dt><code>added</code></dt><dd><p>New fields added to result arrayOp. String vector or NULL.</p></dd>

<dt><code>excluded</code></dt><dd><p>Fields excluded from <code>self</code>. String vector or NULL.</p></dd>

<dt><code>dtypes</code></dt><dd><p>NULL or a named list of data types for fields of the result arrayOp,
where names are field names, values (strings) are data types.</p></dd>

<dt><code>dim_specs</code></dt><dd><p>NULL or a named list of array dimension specs,
where names are dimension names, values (strings) are dimension specs in scidb format.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-limit"></a></p><h3>Method <code>limit()</code></h3>
<p>Create a new arrayOp that encapsulate AFL for the first <code>n</code> cells of 'self'</p>
<p>We still need to append a <code>to_df</code> call to download the result as data frame.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>limit</span>(<span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>5</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>n</code></dt><dd><p>How many cells to take</p></dd>

<dt><code>skip</code></dt><dd><p>How many rows to skip before taking</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new ArrayOp instance</p>
<p><hr>
<a id="method-cell_count"></a></p><h3>Method <code>cell_count()</code></h3>
<p>Return the number of cells of 'self'</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>cell_count</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>A number of cells if the AFL that 'self' encapsulates is run.</p>
<p><hr>
<a id="method-summarize_array"></a></p><h3>Method <code>summarize_array()</code></h3>
<p>Return a data frame of the summary of the 'self' array</p>
<p>Implemented by scidb 'summarize' operator</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>summarize_array</span>(<span class='kw'>by_attribute</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>, <span class='kw'>by_instance</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>by_attribute</code></dt><dd><p>Summarize by array attributes</p></dd>

<dt><code>by_instance</code></dt><dd><p>Summarize by array scidb instances</p></dd>

<dt><code>return</code></dt><dd><p>A data frame of the 'self' array summary</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-sync_schema"></a></p><h3>Method <code>sync_schema()</code></h3>
<p>Create a new arrayOp with actual schema from SciDB or 'self' if
<code>self$is_schema_from_scidb == T</code>.</p>
<p>Useful in confirmming the schema of complex array operations.
If the array schema is already retrieved from SciDB, then just return self.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>sync_schema</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An arrayOp instance</p>
<p><hr>
<a id="method-group_by"></a></p><h3>Method <code>group_by()</code></h3>
<p>Create a new arrayOp with 'group by' fields</p>
<p>The result arrayOp is identical to self except for the 'group_by' fields.
Useful for <code>summarize</code> function, which will be converted into <code>grouped_aggregate</code> operations.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>group_by</span>(<span class='no'>...</span>)</pre><p></div></p>

<h3>Returns</h3>
<p>An arrayOp instance with group_by fields</p>
<p><hr>
<a id="method-summarize"></a></p><h3>Method <code>summarize()</code></h3>
<p>Create a new arrayOp with aggregated fields</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>summarize</span>(<span class='no'>...</span>, <span class='kw'>.dots</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>...</code></dt><dd><p>aggregation expressions in R syntax. Names of expressions are optional.
If provided, names will be the fields of result arrayOp; otherwise field
names are auto generated by scidb.
Same syntax as <code>...</code> in 'filter' and 'mutate' functions.</p></dd>

<dt><code>.dots</code></dt><dd><p>a list of aggregation expressions. Similar to '.dots' in
'mutate' and 'transmute'.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-to_afl"></a></p><h3>Method <code>to_afl()</code></h3>
<p>AFL string encapsulated by of the self ArrayOp</p>
<p>AFL can be either an scidb array name or array operation(s) on array(s).</p>
<p>The ArrayOp instance may have 'selected' fields but they are not reflected in the result.
'selected' fields are not reflected here, but determines which fields are retained in <code>to_df()</code> calls.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_afl</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>an AFL expression string</p>
<p><hr>
<a id="method-to_schema_str"></a></p><h3>Method <code>to_schema_str()</code></h3>
<p>Return a schema representation of the ArrayOp <code>&lt;attr1:type1 [, attr2:type2 ...]&gt; [dim1 [;dim2]]</code></p>
<p>Unless <code>sync_schema()</code> is called, the schema may be inferred locally in R to save round trips between R and SciDB server.
SciDB data frames have hidden dimensions that start with <code>$</code></p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_schema_str</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>SciDB schema string</p>
<p><hr>
<a id="method-to_df_all"></a></p><h3>Method <code>to_df_all()</code></h3>
<p>Download query result of self's AFL string with all self's fields.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_df_all</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An R data frame with columns from self's dimensions and
attributes if no fields are selcted, or the selcted fields.</p>
<p><hr>
<a id="method-to_df"></a></p><h3>Method <code>to_df()</code></h3>
<p>Download query result of self's AFL string with all self's attributes.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>to_df</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An R data frame with columns from self's attributes if no fields
are selected, or the selcted fields only.</p>
<p><hr>
<a id="method-execute"></a></p><h3>Method <code>execute()</code></h3>
<p>Execute the AFL string for pure side effect without result returned.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>execute</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>self</p>
<p><hr>
<a id="method-versions"></a></p><h3>Method <code>versions()</code></h3>
<p>Return a data frame of all self's versions</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>versions</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>An R data frame with columns: version_id and timestamp</p>
<p><hr>
<a id="method-remove_versions"></a></p><h3>Method <code>remove_versions()</code></h3>
<p>Remove array versions of self</p>
<p>Only applicable to persistent arrays.
<strong>Warning</strong>: This function will be executed effectively in scidb without
extra 'execute()' and cannot be undone.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>remove_versions</span>(<span class='kw'>version_id</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>version_id</code></dt><dd><p>NULL or a number. When set to NULL, all array versions
are removed except for the latest one. When set to an number, must be
a valid version_id of self, in which case all versions up to the 'version_id'
are removed.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>NULL</p>
<p><hr>
<a id="method-remove_array"></a></p><h3>Method <code>remove_array()</code></h3>
<p>Remove array versions of self</p>
<p>Only applicable to persistent arrays.
<strong>Warning</strong>: This function will be executed effectively in scidb without
extra 'execute()' and cannot be undone.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>remove_array</span>()</pre><p></div></p>

<h3>Returns</h3>
<p>NULL</p>
<p><hr>
<a id="method-inner_join"></a></p><h3>Method <code>inner_join()</code></h3>
<p>Inner join two arrays: 'self' (left) and 'right'</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate-joins.html'>dplyr::inner_join</a></code>, the result arrayOp performs an inner join.
For both left and right arrays, only selected fields are included in the result arrayOp.
If no fields are selected, then all fields are treated as selected.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>inner_join</span>(
  <span class='no'>right</span>,
  <span class='kw'>on_left</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>on_right</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>on_both</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>left_alias</span> <span class='kw'>=</span> <span class='st'>"_L"</span>,
  <span class='kw'>right_alias</span> <span class='kw'>=</span> <span class='st'>"_R"</span>,
  <span class='kw'>join_mode</span> <span class='kw'>=</span> <span class='st'>"equi_join"</span>,
  <span class='kw'>settings</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>right</code></dt><dd><p>An arrayOp instance</p></dd>

<dt><code>on_left</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>on_right</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>on_both</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'. If not NULL,
must be fields of both operands.</p></dd>

<dt><code>left_alias</code></dt><dd><p>Alias for left array to resolve potential conflicting fields in result</p></dd>

<dt><code>right_alias</code></dt><dd><p>Alias for right array to resolve potential conflicting fields in result</p></dd>

<dt><code>join_mode</code></dt><dd><p>String 'equi_join' or 'cross_join'. The latter requires
join keys are all dimensions of both operands, which is more strigenet than 'equi_join'
with the benifit of non-materializing result in scidb.</p></dd>

<dt><code>settings</code></dt><dd><p>A named list as join settings. E.g. <code><a href='https://rdrr.io/r/base/list.html'> list(algorithm = "'hash_replicate_right'")</a></code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-left_join"></a></p><h3>Method <code>left_join()</code></h3>
<p>Left join two arrays: 'self' (left) and 'right'</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate-joins.html'>dplyr::left_join</a></code>, the result arrayOp performs a left join.
For both left and right arrays, only selected fields are included in the result arrayOp.
If no fields are selected, then all fields are treated as selected.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>left_join</span>(
  <span class='no'>right</span>,
  <span class='kw'>on_left</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>on_right</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>on_both</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>left_alias</span> <span class='kw'>=</span> <span class='st'>"_L"</span>,
  <span class='kw'>right_alias</span> <span class='kw'>=</span> <span class='st'>"_R"</span>,
  <span class='kw'>settings</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>right</code></dt><dd><p>An arrayOp instance</p></dd>

<dt><code>on_left</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>on_right</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>on_both</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'. If not NULL,
must be fields of both operands.</p></dd>

<dt><code>left_alias</code></dt><dd><p>Alias for left array to resolve potential conflicting fields in result</p></dd>

<dt><code>right_alias</code></dt><dd><p>Alias for right array to resolve potential conflicting fields in result</p></dd>

<dt><code>settings</code></dt><dd><p>A named list as join settings. E.g. <code><a href='https://rdrr.io/r/base/list.html'> list(algorithm = "'hash_replicate_right'")</a></code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-right_join"></a></p><h3>Method <code>right_join()</code></h3>
<p>Right join two arrays: 'self' (left) and 'right'</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/mutate-joins.html'>dplyr::right_join</a></code>, the result arrayOp performs a right join.
For both left and right arrays, only selected fields are included in the result arrayOp.
If no fields are selected, then all fields are treated as selected.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>right_join</span>(
  <span class='no'>right</span>,
  <span class='kw'>on_left</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>on_right</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>on_both</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>left_alias</span> <span class='kw'>=</span> <span class='st'>"_L"</span>,
  <span class='kw'>right_alias</span> <span class='kw'>=</span> <span class='st'>"_R"</span>,
  <span class='kw'>settings</span> <span class='kw'>=</span> <span class='kw'>NULL</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>right</code></dt><dd><p>An arrayOp instance</p></dd>

<dt><code>on_left</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>on_right</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'.</p></dd>

<dt><code>on_both</code></dt><dd><p>NULL or a string vector as join keys. If set to NULL, join
keys are inferred as shared fields of 'left' and 'right'. If not NULL,
must be fields of both operands.</p></dd>

<dt><code>left_alias</code></dt><dd><p>Alias for left array to resolve potential conflicting fields in result</p></dd>

<dt><code>right_alias</code></dt><dd><p>Alias for right array to resolve potential conflicting fields in result</p></dd>

<dt><code>settings</code></dt><dd><p>A named list as join settings. E.g. <code><a href='https://rdrr.io/r/base/list.html'> list(algorithm = "'hash_replicate_right'")</a></code></p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>A new arrayOp instance</p>
<p><hr>
<a id="method-semi_join"></a></p><h3>Method <code>semi_join()</code></h3>
<p>Return an arrayOp instance with same schema as self and content cells that
match the cells of 'df_or_arrayop'.</p>
<p>Similar to <code><a href='https://dplyr.tidyverse.org/reference/filter-joins.html'>dplyr::semi_join</a></code>, the result has the same schema as the left
operand 'self' and with content filtered by 'df_or_arrayop'.</p>
<p>params <code>field_mapping</code>, <code>lower_bound</code> and <code>upper_bound</code>, if provided, must be named list,
where the.names are from the source array (i.e. self), and values are from
the right operand <code>df_or_arrayop</code></p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>semi_join</span>(
  <span class='no'>df_or_arrayop</span>,
  <span class='kw'>field_mapping</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>lower_bound</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>upper_bound</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>mode</span> <span class='kw'>=</span> <span class='st'>"auto"</span>,
  <span class='kw'>filter_threshold</span> <span class='kw'>=</span> <span class='fl'>200L</span>,
  <span class='kw'>upload_threshold</span> <span class='kw'>=</span> <span class='fl'>6000L</span>
)</pre><p></div></p>

<h3>Arguments</h3>
<p><div class="arguments"></p><dl>
<dt><code>df_or_arrayop</code></dt><dd><p>An R data frame or arrayOp instance.</p></dd>

<dt><code>mode</code></dt><dd><p>String of 'filter', 'cross_between', 'index_lookup' or 'auto'</p></dd>

<dt><code>filter_threshold</code></dt><dd><p>A number below which the 'filter' mode is used
unless a mode other than 'auto' is provided.</p></dd>

<dt><code>upload_threshold</code></dt><dd><p>A number below which the 'df_or_arrayop' data frame
is compield into a build literal array; otherwise uploaded to scidb as a regular array.
Only applicable when 'df_or_arrayop' is an R data frame.</p></dd>

</dl><p></div></p>
<h3>Returns</h3>
<p>An arrayOp instance</p>
<p><hr>
<a id="method-persist"></a></p><h3>Method <code>persist()</code></h3>

<h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>persist</span>(<span class='kw'>save_array_name</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>.temp</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>, <span class='kw'>.gc</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre><p></div></p>

<p><hr>
<a id="method-is_persistent"></a></p><h3>Method <code>is_persistent()</code></h3>

<h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>is_persistent</span>()</pre><p></div></p>

<p><hr>
<a id="method-exists_persistent_array"></a></p><h3>Method <code>exists_persistent_array()</code></h3>

<h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>exists_persistent_array</span>()</pre><p></div></p>

<p><hr>
<a id="method-array_meta_data"></a></p><h3>Method <code>array_meta_data()</code></h3>

<h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>array_meta_data</span>()</pre><p></div></p>

<p><hr>
<a id="method-finalize"></a></p><h3>Method <code>finalize()</code></h3>
<p>A finalize function executed when the 'self' instance is garbage collected in R</p>
<p>If an arrayOp is marked as .gc = T, then it should be removed from scidb
when this function is executed.</p><h3>Usage</h3>
<p><div class="r"></p><pre><span class='no'>ArrayOpBase</span>$<span class='fu'>finalize</span>()</pre><p></div></p>




  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by  Paradigm4.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.9000.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>



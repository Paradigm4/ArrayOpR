<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Toolset for Object-Oriented SciDB Array Operations/Operands • arrayop</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="bootstrap-toc.css">
<script src="bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="pkgdown.css" rel="stylesheet">
<script src="pkgdown.js"></script><meta property="og:title" content="Toolset for Object-Oriented SciDB Array Operations/Operands">
<meta property="og:description" content="ArrayOp abstracts away AFL generation by unifying array operations and array operands.">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-home">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="index.html">arrayop</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="articles/arrayop.html">Get started</a>
</li>
<li>
  <a href="reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="articles/semi_join.html">Semi Join</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/Paradigm4/ArrayOpR/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="contents col-md-9">

<div id="1-arrayopr" class="section level1">
<div class="page-header"><h1 class="hasAnchor">
<a href="#1-arrayopr" class="anchor"></a>1. ArrayOpR</h1></div>
<p>An R package <code>arrayop</code> for object-oriented scidb operations/operands</p>
<!-- TOC -->
<ul>
<li>
<a href="#1-arrayopr">1. ArrayOpR</a>
<ul>
<li><a href="#11-installation">1.1. Installation</a></li>
</ul>
</li>
<li>
<a href="#2-overview">2. Overview</a>
<ul>
<li><a href="#21-synopsis">2.1. Synopsis</a></li>
<li><a href="#22-what-is-arrayop">2.2. What is ArrayOp?</a></li>
<li><a href="#23-arrayop-class-features">2.3. ArrayOp class features</a></li>
<li>
<a href="#24-a-working-example-and-tests">2.4. A working example and tests</a>
<ul>
<li><a href="#241-integration-tests">2.4.1. Integration tests</a></li>
<li><a href="#242-unit-tests">2.4.2. Unit tests</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#3-create-a-repo-instance">3. Create a Repo instance</a>
<ul>
<li><a href="#31-repo-operations">3.1. Repo operations</a></li>
<li>
<a href="#32-prep-the-repo">3.2. Prep the Repo</a>
<ul>
<li><a href="#321-register-array-schemas">3.2.1. Register Array Schemas</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#4-get-arrayop-instances">4. Get ArrayOp instances</a>
<ul>
<li><a href="#41-from-registered-array-aliases">4.1. From registered array aliases</a></li>
<li><a href="#42-from-array-names-directly">4.2. From array names directly</a></li>
</ul>
</li>
<li>
<a href="#5-arrayop-instance-functions">5. ArrayOp instance functions</a>
<ul>
<li><a href="#51-lazy-evaluation">5.1. Lazy evaluation</a></li>
<li>
<a href="#52-query">5.2. Query</a>
<ul>
<li><a href="#521-where">5.2.1. where</a></li>
<li>
<a href="#522-match">5.2.2. match</a>
<ul>
<li><a href="#5221-match-by-data-frame-with-filter-mode">5.2.2.1. Match by data frame with filter mode</a></li>
<li><a href="#5222-match-another-arrayop-with-cross_between-mode">5.2.2.2. Match another ArrayOp with cross_between mode</a></li>
</ul>
</li>
<li>
<a href="#523-join-two-arrayops">5.2.3. join two ArrayOps</a>
<ul>
<li><a href="#5231-use-select-to-specify-fields-in-join-result">5.2.3.1. Use ‘select’ to specify fields in ‘join’ result</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#53-io">5.3. I/O</a>
<ul>
<li>
<a href="#531-load_file">5.3.1. load_file</a>
<ul>
<li><a href="#5311-specify-file-headers-when-file-fields-do-not-match-exactly-the-template-fields">5.3.1.1. Specify file headers when file fields do not match exactly the template fields</a></li>
<li><a href="#5312-result-schema">5.3.1.2. Result schema</a></li>
<li><a href="#5313-customized-field-conversion">5.3.1.3. Customized field conversion</a></li>
</ul>
</li>
<li>
<a href="#532-write_to">5.3.2. write_to</a>
<ul>
<li><a href="#5321-all-fields-content-are-available">5.3.2.1. All fields content are available</a></li>
<li><a href="#5322-auto-incremented-field">5.3.2.2. Auto-incremented field</a></li>
<li><a href="#5323-anti-collision-field">5.3.2.3. Anti-collision field</a></li>
<li><a href="#5324-combining-auto-increment-field-and-anti-collision-field">5.3.2.4. Combining auto-increment field and anti-collision field</a></li>
</ul>
</li>
<li><a href="#533-build_new">5.3.3. build_new</a></li>
</ul>
</li>
<li>
<a href="#54-schema-change">5.4. Schema change</a>
<ul>
<li><a href="#541-reshape">5.4.1. reshape</a></li>
<li><a href="#542-spawn">5.4.2. spawn</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#6-create-afl-manually">6. Create AFL manually</a>
<ul>
<li><a href="#61-r-infix-functions-are-converted-to-scidb-operatorsfunctions">6.1. R infix functions are converted to scidb operators/functions</a></li>
<li><a href="#62-run-generated-afl-in-scidb">6.2. Run generated AFL in scidb</a></li>
</ul>
</li>
</ul>
<!-- /TOC --><div id="11-installation" class="section level2">
<h2 class="hasAnchor">
<a href="#11-installation" class="anchor"></a>1.1. Installation</h2>
<pre class="{r}"><code><a href="https://devtools.r-lib.org//reference/remote-reexports.html">devtools::install_github("Paradigm4/ArrayOpR")

# Or a development branch:
devtools::install_github("Paradigm4/ArrayOpR", ref = 'v19_v18')</a></code></pre>
<p>To remove <code>arrayop</code>,</p>
<pre class="{r}"><code><a href="https://rdrr.io/r/utils/remove.packages.html">remove.packages('arrayop')</a></code></pre>
</div>
</div>
<div id="2-overview" class="section level1">
<h1 class="hasAnchor">
<a href="#2-overview" class="anchor"></a>2. Overview</h1>
<div id="21-synopsis" class="section level2">
<h2 class="hasAnchor">
<a href="#21-synopsis" class="anchor"></a>2.1. Synopsis</h2>
<ul>
<li>Get <code>ArrayOp</code> instances from a <code>Repo</code>
</li>
<li>Perform operations on <code>ArrayOp</code> instances
<ul>
<li>Most <code>ArrayOp</code> operations result in new <code>ArrayOp</code> instances (immutable)</li>
<li>Compose simple or complex operations by chaining/composing <code>ArrayOp</code>s.</li>
</ul>
</li>
<li>Materialize <code>ArrayOp</code> instances in a <code>Repo</code> and expect results.
<ul>
<li>Or execute commands for side-effects only.</li>
</ul>
</li>
</ul>
</div>
<div id="22-what-is-arrayop" class="section level2">
<h2 class="hasAnchor">
<a href="#22-what-is-arrayop" class="anchor"></a>2.2. What is ArrayOp?</h2>
<p>An <code>ArrayOp</code> instance refers to any of the below:</p>
<ul>
<li>scidb array</li>
<li>a query of one scidb array or multiple arrays</li>
<li>an I/O operation in scidb</li>
<li>combination of the above</li>
</ul>
<p><code>ArrayOp</code> is more than a data strucutre for AFL in that:</p>
<ul>
<li>field validation in R</li>
<li>convenience functions that enable users focus more on data logic rather than scidb details.</li>
</ul>
<p><code>Repo</code> is explained below.</p>
</div>
<div id="23-arrayop-class-features" class="section level2">
<h2 class="hasAnchor">
<a href="#23-arrayop-class-features" class="anchor"></a>2.3. ArrayOp class features</h2>
<p>Regardless of how an <code>ArrayOp</code> instance <code>arrayOp</code> is created, it has the full features listed below instance functions:</p>
<ul>
<li>Simple Query
<ul>
<li><code>where</code></li>
<li><code>match</code></li>
</ul>
</li>
<li>Complex Query
<ul>
<li><code>join</code></li>
<li><code>select</code></li>
</ul>
</li>
<li>IO
<ul>
<li><code>build_new</code></li>
<li><code>load_file</code></li>
<li><code>write_to</code></li>
</ul>
</li>
<li>Schema change
<ul>
<li><code>spawn</code></li>
<li><code>create_new_with_same_schema</code></li>
<li><code>get_schema_str</code></li>
<li><code>reshape</code></li>
</ul>
</li>
<li>Materialize
<ul>
<li><code>query</code></li>
<li><code>execute</code></li>
</ul>
</li>
</ul>
<p>The latest <code>arrayop</code> package supports scidb v18 and v19. Version switch is made during <code>Repo</code> creation (see below for details).</p>
</div>
<div id="24-a-working-example-and-tests" class="section level2">
<h2 class="hasAnchor">
<a href="#24-a-working-example-and-tests" class="anchor"></a>2.4. A working example and tests</h2>
<div id="241-integration-tests" class="section level3">
<h3 class="hasAnchor">
<a href="#241-integration-tests" class="anchor"></a>2.4.1. Integration tests</h3>
<p>During <code>arrayop</code> package development, <a href="R/test_db.R">an integration test script</a> that runs on both scidb v19 and v18 ensures <code>arraop</code> passes all tests in action.</p>
</div>
<div id="242-unit-tests" class="section level3">
<h3 class="hasAnchor">
<a href="#242-unit-tests" class="anchor"></a>2.4.2. Unit tests</h3>
<p>The unit tests do not depend on a scidb connection. But they shows how AFL is generated under the hood. Feel free to take a look at the <a href="tests/testthat/">unit tests</a> or dive right into the <a href="tests/testthat/base/test_array_op_base.R">tests on ArrayOpBase class</a>.</p>
</div>
</div>
</div>
<div id="3-create-a-repo-instance" class="section level1">
<h1 class="hasAnchor">
<a href="#3-create-a-repo-instance" class="anchor"></a>3. Create a Repo instance</h1>
<pre class="{r}"><code>repo = newRepo(default_namespace = 'test_ns', db = db)</code></pre>
<p>The <code>Repo</code> instance is an abstraction of a scidb installation, where we perform common scidb related array operations without writing raw AFL.</p>
<ul>
<li>
<code>default_namespace</code>: an existing scidb namespace.</li>
<li>
<code>db</code> is a scidb connection instance which is returned by <code>db = scidb::connect(...)</code> where <code>...</code> is scidb connection params.</li>
</ul>
<div id="31-repo-operations" class="section level2">
<h2 class="hasAnchor">
<a href="#31-repo-operations" class="anchor"></a>3.1. Repo operations</h2>
<p>There are two kinds of operations of <code>repo</code>:</p>
<ul>
<li>
<code>repo$query(what)</code>: pass in a query and get a result in return.</li>
<li>
<code>repo$execute(what)</code>: only execute a command and do NOT expect result.</li>
</ul>
<p>In both operations, param <code>what</code> is either a raw string or <code>ArrayOp</code> instance. In the latter case <code>ArrayOp$to_df_afl()</code> is called and an AFL string is returned and then passed to <code>query</code>/<code>execute</code>.</p>
<p>The advantage of using <code>arrayop</code> package compared to raw AFL is that we can compose complex queries/commands with intuitive <code>ArrayOp</code> functions.</p>
</div>
<div id="32-prep-the-repo" class="section level2">
<h2 class="hasAnchor">
<a href="#32-prep-the-repo" class="anchor"></a>3.2. Prep the Repo</h2>
<div id="321-register-array-schemas" class="section level3">
<h3 class="hasAnchor">
<a href="#321-register-array-schemas" class="anchor"></a>3.2.1. Register Array Schemas</h3>
<p>After repo creation, we need to register exsiting arrays onto <code>repo</code> since no auto-scanning of scidb namespace is performed.</p>
<pre class="{r}"><code># By default the repo namespace is used. So myArray1 refers to test_ns.A
repo$register_schema_alias_by_array_name('myArray1', 'A')

# In case of another namespace, we can specify the full array name with param is_full_name = T.
repo$register_schema_alias_by_array_name('myArray2', 'another_ns.myArray2', is_full_name = T)</code></pre>
<p>NOTE: for performance concerns, array name is validated during registeration.</p>
</div>
</div>
</div>
<div id="4-get-arrayop-instances" class="section level1">
<h1 class="hasAnchor">
<a href="#4-get-arrayop-instances" class="anchor"></a>4. Get ArrayOp instances</h1>
<div id="41-from-registered-array-aliases" class="section level2">
<h2 class="hasAnchor">
<a href="#41-from-registered-array-aliases" class="anchor"></a>4.1. From registered array aliases</h2>
<p>Once registered, <code>ArrayOp</code> instance will be created on first access and cached thereafter. Here <code>array1</code> and <code>array2</code> are valid <code>ArrayOp</code> instances if the registered arrays do exist in scidb. Notice <code>array1</code> and <code>array2</code> exist in different namespaces.</p>
<pre class="{r}"><code>array1 = repo$get_alias_schema('myArray1')
array2 = repo$get_alias_schema('myArray2')</code></pre>
</div>
<div id="42-from-array-names-directly" class="section level2">
<h2 class="hasAnchor">
<a href="#42-from-array-names-directly" class="anchor"></a>4.2. From array names directly</h2>
<p>In cases of one-time-use arrays, we may not want to register arrays before use. We can get <code>ArrayOp</code> instances directly from fully-qualified array names.</p>
<pre class="{r}"><code>array3 = repo$load_schema_from_db('test_ns.array_name')</code></pre>
</div>
</div>
<div id="5-arrayop-instance-functions" class="section level1">
<h1 class="hasAnchor">
<a href="#5-arrayop-instance-functions" class="anchor"></a>5. ArrayOp instance functions</h1>
<p><code>ArrayOp</code> functions validate performed operations based on which operand’s schema (attributes, dimensions, data types and dimension specs) and throw informative errors wherever possible.</p>
<p>Suppose we have two arrays <code>A</code> and <code>B</code> in scidb:</p>
<pre class="{r}"><code>create array A &lt;aa:string, ab:int64&gt; [daa=0:*:0:*; dab=0:*:0:*]
create array B &lt;ba:string, bb:int64&gt; [dba=0:*:0:*; dbb=0:*:0:*]</code></pre>
<p>And they are retrieved in R with <code>arrayop</code>:</p>
<pre class="{r}"><code>repo$register_schema_alias_by_array_name('a', 'A')
repo$register_schema_alias_by_array_name('b', 'B')
a = repo$get_alias_schema('A')
b = repo$get_alias_schema('B')</code></pre>
<div id="51-lazy-evaluation" class="section level2">
<h2 class="hasAnchor">
<a href="#51-lazy-evaluation" class="anchor"></a>5.1. Lazy evaluation</h2>
<p>Unless one of the following is invoked, there is no scidb query performed:</p>
<ul>
<li><code>result = repo$query(any_array_op)</code></li>
<li><code>repo$execute(any_array_op)</code></li>
</ul>
</div>
<div id="52-query" class="section level2">
<h2 class="hasAnchor">
<a href="#52-query" class="anchor"></a>5.2. Query</h2>
<div id="521-where" class="section level3">
<h3 class="hasAnchor">
<a href="#521-where" class="anchor"></a>5.2.1. where</h3>
<p>Filter by array fields:</p>
<p><code>res = a$where(aa == 'value')</code></p>
<p><code>res = a$where(aa == 'value' &amp;&amp; daa &gt; 0)</code> is equivalent to <code>a$where(aa == 'value', daa &gt; 0)</code></p>
<p><code>res = a$where(strlen(aa) == 1)</code></p>
<p>Get the result data frame with <code>repo$query( a$where(aa == 'value') )</code> or <code>repo$query( res )</code></p>
<p>Any non-literal R name is treated as array field names, and functions treated as scidb functions (eg. <code>strlen</code> function above). If we want to reference functions/symbols in R context, prefix expressions with <code>!!</code>. E.g: <code>res = a$where( ab %in% !!c(1,2,3))</code>, where <code>!!c(1,2,3)</code> is evaluated to a numeric vector in R first before get compiled to AFL. Without the <code>!!</code>, <code>c</code> is converted to a scidb function which doesn’t exist.</p>
<p>Existing R packages such as <code>dplyr</code> and <code>data.table</code> try to be clever in deciding context between R and the data frame, but that prohibits using R variable names shared by data frame fields. For example, in <code>arrayop</code>, you can do:</p>
<pre class="{r}"><code>aa = 'value'
a$where(aa == !!aa)</code></pre>
<p>Whereas in <code>data.table</code> and <code>dplyr</code>, <code>a$filter(aa == aa)</code> is equivelant to <code>a$filter(TRUE)</code> which returns all records.</p>
</div>
<div id="522-match" class="section level3">
<h3 class="hasAnchor">
<a href="#522-match" class="anchor"></a>5.2.2. match</h3>
<p><code>match</code> operation also filters array content like <code>where</code>, but does it differently. While <code>where</code> filters arrays by a filter expression, <code>match</code> filters arrays by an existing R data frame or scidb array or array expression denoted by ArrayOp.</p>
<div id="5221-match-by-data-frame-with-filter-mode" class="section level4">
<h4 class="hasAnchor">
<a href="#5221-match-by-data-frame-with-filter-mode" class="anchor"></a>5.2.2.1. Match by data frame with filter mode</h4>
<pre class="{r}"><code>df = data.frame(ab = c(1, 2))
# These two are equivalent
res1 = a$match(df, op_mode = 'filter')
res2 = a$filter(ab == 1 || ab == 2)</code></pre>
<p>Fields are matched by names.</p>
<pre class="{r}"><code>df = data.frame(daa = c(1, 2))
# These two are equivalent
res1 = a$match(df, op_mode = 'filter')
res2 = a$filter(daa == 1 || dab == 2)</code></pre>
</div>
<div id="5222-match-another-arrayop-with-cross_between-mode" class="section level4">
<h4 class="hasAnchor">
<a href="#5222-match-another-arrayop-with-cross_between-mode" class="anchor"></a>5.2.2.2. Match another ArrayOp with cross_between mode</h4>
<pre class="{r}"><code>a$match(b, op_mode = 'cross_between', field_mapping = list(daa == 'dba', dab = 'dbb'))</code></pre>
<p>Notice <code>field_mapping</code> param is set since <code>a</code> and <code>b</code> don’t have matching fields, otherwise matching fields are detected if <code>field_mapping</code> is not set.</p>
</div>
</div>
<div id="523-join-two-arrayops" class="section level3">
<h3 class="hasAnchor">
<a href="#523-join-two-arrayops" class="anchor"></a>5.2.3. join two ArrayOps</h3>
<pre class="{r}"><code>a$join(b, on_left='daa', on_right='dba')
a$join(b, on_left=c('daa', 'aa'), on_right=c('dba', 'ab')</code></pre>
<p>Here <code>a</code> is the left and <code>b</code> is the right operand. By default, only join keys and array attributes are retained in the result.</p>
<div id="5231-use-select-to-specify-fields-in-join-result" class="section level4">
<h4 class="hasAnchor">
<a href="#5231-use-select-to-specify-fields-in-join-result" class="anchor"></a>5.2.3.1. Use ‘select’ to specify fields in ‘join’ result</h4>
<p>Select fields on left operand:</p>
<pre class="{r}"><code>a$select('aa', 'ab', 'daa', 'dab')$join(b, on_left='daa', on_right='dba')</code></pre>
<p>Select fields on both operands:</p>
<pre class="{r}"><code>a$select('aa', 'dab')$join(b$select('ba', 'dbb'), on_left='daa', on_right='dba')</code></pre>
<p>NOTE: if there is <code>select</code>ed fields on at least one operand, the <code>join</code> result schema will conform to the selected fields. Otherwise, <code>join</code> result without <code>select</code>ed fields will follow the convention of scidb <code>equi_join</code> (i.e. drop dimensions, keep attributes and keep left join keys).</p>
</div>
</div>
</div>
<div id="53-io" class="section level2">
<h2 class="hasAnchor">
<a href="#53-io" class="anchor"></a>5.3. I/O</h2>
<div id="531-load_file" class="section level3">
<h3 class="hasAnchor">
<a href="#531-load_file" class="anchor"></a>5.3.1. load_file</h3>
<p><code>load_file</code> creates a new ArrayOp from a template ArrayOp and a file path, which is normally used in another operation, e.g. <code>a$load_file(...)$write_to(b)</code></p>
<p><code>result = a$load_file('file_path')</code></p>
<p>By default, file headers are assumed to match the template perfectly. In the example above, the file <code>file_path</code> should have four columns: <code>daa</code>, <code>dab</code>, <code>aa</code> and <code>ab</code>, each matches the template field data type in the exact order.</p>
<div id="5311-specify-file-headers-when-file-fields-do-not-match-exactly-the-template-fields" class="section level4">
<h4 class="hasAnchor">
<a href="#5311-specify-file-headers-when-file-fields-do-not-match-exactly-the-template-fields" class="anchor"></a>5.3.1.1. Specify file headers when file fields do not match exactly the template fields</h4>
<p>The <code>file_header</code> param specifies the expected headers in the file. Only those matching the template are loaded. Non-matching headers are irrelevant and are ignored.</p>
<p><code>result = a$load_file('file_path', file_headers = c('daa', 'skip', 'aa', 'ab', 'skip')</code></p>
</div>
<div id="5312-result-schema" class="section level4">
<h4 class="hasAnchor">
<a href="#5312-result-schema" class="anchor"></a>5.3.1.2. Result schema</h4>
<p>The result schema has a collection of attributes comprised of matching template fields (dimensions and/or attributes) and doesn’t have meaningful dimensions, due to the implementation of the scidb <code>aio_input</code> plugin.</p>
</div>
<div id="5313-customized-field-conversion" class="section level4">
<h4 class="hasAnchor">
<a href="#5313-customized-field-conversion" class="anchor"></a>5.3.1.3. Customized field conversion</h4>
<p>The input file can have errors or need data conversion. E.g. <code>a$load_file('file_path',      field_conversion = list(aa = 'int64(@)+42', daa = 'dcast(@, bool(null))'))</code> where the <code>@</code> will be replaced by numbered attributes (a0, a1, …) in <code>aio_input</code>.</p>
</div>
</div>
<div id="532-write_to" class="section level3">
<h3 class="hasAnchor">
<a href="#532-write_to" class="anchor"></a>5.3.2. write_to</h3>
<p><code>a$write_to(b)</code> creates an ArrayOp that writes the content of the source array <code>a</code> to the target array <code>b</code>.</p>
<p>The optional param <code>append</code> defaults to TRUE, applies to all below use cases, and determines whether the operator <code>insert</code> or <code>store</code> is used in AFL.</p>
<div id="5321-all-fields-content-are-available" class="section level4">
<h4 class="hasAnchor">
<a href="#5321-all-fields-content-are-available" class="anchor"></a>5.3.2.1. All fields content are available</h4>
<p><code>a$write_to(b)</code></p>
<p>If the field data types of <code>a</code> match exactly those of <code>b</code>, then regardless of field names, <code>a</code> is <code>insert</code>ed or <code>store</code>d into <code>b</code> depending on the <code>append</code> param.</p>
<p>Otherwise, <code>a</code> is first <code>redimension</code>ed and then processed similarly to the above case <strong>only</strong> if all of the target <code>b</code> fields are present on <code>a</code>, which is required by the scidb <code>redimension</code> operator.</p>
</div>
<div id="5322-auto-incremented-field" class="section level4">
<h4 class="hasAnchor">
<a href="#5322-auto-incremented-field" class="anchor"></a>5.3.2.2. Auto-incremented field</h4>
<p><code>a$write_to(b, source_auto_increment = c(ab=0), target_auto_increment = c(bb=1))</code></p>
<p>In cases of auto-incremented field, its value is normally not loaded from files, but calculated during the data loading. We can specify the params <code>source_auto_increment</code> and <code>target_auto_increment</code>, both named single-length integers, to instruct how the field will be auto incremented.</p>
<p>The <code>source_auto_increment</code> param is normally a field from the result of <code>load_file</code>, <code>build_new</code> or <code>reshape</code> functions. Its value is normally <code>0</code>, as in scidb <code>unpack</code> and <code>build</code> operators.</p>
<p>The <code>target_auto_increment</code> param is a field of the target. Its value only affects the initial data loading operation.</p>
</div>
<div id="5323-anti-collision-field" class="section level4">
<h4 class="hasAnchor">
<a href="#5323-anti-collision-field" class="anchor"></a>5.3.2.3. Anti-collision field</h4>
<p>scidb does not allow duplicated cell coordinates, i.e. every combination of all dimensions must be unique. In cases of multiple cell coordinates are desired, an artificial dimension, namely the <code>anti_collision_field</code>, is required to circumvent the scidb restriction. The syntax is shown below:</p>
<p><code>a$write_to(b, anti_collision_field = 'alt_id')</code></p>
</div>
<div id="5324-combining-auto-increment-field-and-anti-collision-field" class="section level4">
<h4 class="hasAnchor">
<a href="#5324-combining-auto-increment-field-and-anti-collision-field" class="anchor"></a>5.3.2.4. Combining auto-increment field and anti-collision field</h4>
<p><code>a$write_to(b, source_auto_increment = c(ab=0), target_auto_increment = c(bb=1), anti_collision_field = 'alt_id')</code></p>
<p><strong>NOTE</strong>: <code>ArrayOp</code> validates that all the combined source fields (regarless of matching fields, auto-increment field or anti-collision field, where applicable) must constitute the entirety of the target fields.</p>
</div>
</div>
<div id="533-build_new" class="section level3">
<h3 class="hasAnchor">
<a href="#533-build_new" class="anchor"></a>5.3.3. build_new</h3>
<p><code>build_new</code> creates a new ArrayOp from a template ArrayOp and a data frame. The result ArrayOp’s attributes consist of the template’s dimensions and attributes, with an artificial build dimension.</p>
<p><code>result = a$build_new(data.frame(da = c(1,2), aa = c('a', 'b')), artificial_field='z')</code></p>
<p>The data frame is converted to a string literal for scidb <code>build</code> operator. All data frame column names should match the template fields, but not all template fields are required in the data frame. In the example above, the result ArrayOp has a dimension <code>z</code> and two attributes <code>da</code> and <code>aa</code>. The optional param <code>artifical_field</code>, when omitted, defaults to a random string.</p>
<p><code>build_new</code> is faster than uploading a data frame to scidb, but has limitations imposed by <code>shim</code> (reference to be added here).</p>
</div>
</div>
<div id="54-schema-change" class="section level2">
<h2 class="hasAnchor">
<a href="#54-schema-change" class="anchor"></a>5.4. Schema change</h2>
<div id="541-reshape" class="section level3">
<h3 class="hasAnchor">
<a href="#541-reshape" class="anchor"></a>5.4.1. reshape</h3>
<p><code><a href="https://rdrr.io/r/stats/reshape.html">reshape(select, dtypes = NULL, dim_mode = 'keep', artificial_field = .random_attr_name())</a></code></p>
<p><code>a$reshape</code> returns a new ArrayOp that has a subset of the template array <code>a</code>’s fields of which the names and/or data types can be modified.</p>
<p><code>a$reshape(c('aa'))</code> : the result ArrayOp has only one attribute <code>aa</code>, but the dimensions are the same as <code>a</code>, because the param <code>dim_mode</code> defaults to <code>keep</code>.</p>
<p><code>a$reshape(c('aa'), dim_mode = 'drop')</code> : the result ArrayOp has only one attribute <code>aa</code> and no meaningful dimension unless a <code>artificial_field</code> param is provided which is used in scidb <code>unpack</code> operator to get rid of existing dimensions.</p>
<p><code>a$reshape(list('aa', aa_len = strlen(aa)), dtypes = list(aa_len = 'int64'))</code>: a named item in param <code>select</code> is treated as a new, derived field, whose data type can be provided in a <code>dtypes</code> param.</p>
<p>NOTE: <code>reshape</code>d ArrayOp is useful in I/O related operations.</p>
<p>E.g. we can only calculate a field after some initial operations, so the initially loaded ArrayOp can not have the same field name as the <code>write_to</code> target due to field name confliction.</p>
</div>
<div id="542-spawn" class="section level3">
<h3 class="hasAnchor">
<a href="#542-spawn" class="anchor"></a>5.4.2. spawn</h3>
<p><code>spawn</code> is similar to <code>reshape</code> in the sense they both return a new ArrayOp with a modified schema than the template. But <code>spawn</code> differs from <code>reshape</code> in :</p>
<ul>
<li>
<code>spawn</code> only renames or excludes existing template fields, and does not allow new fields.</li>
<li>
<code>spawn</code> result should only be used in another operation for schema template purposes but NOT for AFL in <code>to_afl</code>.</li>
</ul>
<p><code>a$spawn(renamed = NULL, excluded = NULL, dtypes = NULL, dim_specs = NULL)</code></p>
<p><code>a$spawn(renamed = list(aa='attr1', ab='attr2'))</code>: result schema has the template fields <code>aa</code> and <code>ab</code> renamed to <code>attr</code> and <code>attr2</code>, respectively.</p>
<p><code>a$spawn(excluded = c('aa', 'daa'))</code>: template fields <code>aa</code> and <code>daa</code> are excluded in the result schema.</p>
<p>The param <code>dtypes</code> and <code>dim_specs</code> can redefine field data types and dimension specs of the result schema.</p>
<p>NOTE: all the params can be provided in combination with each other. When both <code>renamed</code> and <code>excluded</code> are provided, renaming is performed prior to excluding the fields.</p>
</div>
</div>
</div>
<div id="6-create-afl-manually" class="section level1">
<h1 class="hasAnchor">
<a href="#6-create-afl-manually" class="anchor"></a>6. Create AFL manually</h1>
<p>Not all scidb operations can be achieved directly via ArrayOp instance functions. Sometimes we need to create AFL manually. After all, ArrayOp features are also implemented through AFL, just more user friendly.</p>
<p>The package level function <code><a href="reference/afl.html">afl(...)</a></code> translate R expressions into AFL, where a customized R infix function <code>%func%</code> is converted to an AFL function <code>func</code>, and operands are converted to their proper string forms. See examples below.</p>
<div id="61-r-infix-functions-are-converted-to-scidb-operatorsfunctions" class="section level2">
<h2 class="hasAnchor">
<a href="#61-r-infix-functions-are-converted-to-scidb-operatorsfunctions" class="anchor"></a>6.1. R infix functions are converted to scidb operators/functions</h2>
<p><code><a href="reference/afl.html">afl('a' %op% 'b')</a></code> =&gt; <code>op(a, b)</code></p>
<p><code><a href="reference/afl.html">afl("'a'" %op% 'b')</a></code> =&gt; <code>op('a', b)</code></p>
<p><code><a href="reference/afl.html">afl('a' %op% c('b', 'c'))</a></code> =&gt; <code>op(a, b, c)</code></p>
<p><code><a href="reference/afl.html">afl(arrayOpA %op% 'b')</a></code> =&gt; <code>op(arrayOpA$to_afl(), b)</code></p>
<p><code><a href="reference/afl.html">afl(arrayOpA %op% arrayOpB)</a></code> =&gt; <code>op(arrayOpA$to_afl(), arrayOpB$to_afl())</code></p>
<p><code><a href="reference/afl.html">afl(arrayOpA %filter% 'aa &gt; 0' %apply% c('da', 'da') %project% c('da', 'aa'))</a></code> =&gt; <code>project(apply(filter(arrayOpA$to_afl(),aa &gt; 0),da,da),da,aa)</code></p>
<p>See <a href="tests/testthat/base/test_afl_util.R">relevant unit tests</a> for more details.</p>
<p>NOTE: <code>arrayop</code> does not validate in any way the AFL operands or functions.</p>
</div>
<div id="62-run-generated-afl-in-scidb" class="section level2">
<h2 class="hasAnchor">
<a href="#62-run-generated-afl-in-scidb" class="anchor"></a>6.2. Run generated AFL in scidb</h2>
<p><code>repo$query(afl('a' %op% 'b'))</code> will return the result of the AFL query <code>op(a, b)</code> <code>repo$execute(afl('a' %op% 'b'))</code> will execute the AFL command <code>op(a, b)</code></p>
</div>
</div>

  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <div class="links">
<h2>Links</h2>
<ul class="list-unstyled">
<li>Browse source code at <br><a href="https://github.com/Paradigm4/ArrayOpR/">https://​github.com/​Paradigm4/​ArrayOpR/​</a>
</li>
<li>Report a bug at <br><a href="https://github.com/Paradigm4/ArrayOpR/issues">https://​github.com/​Paradigm4/​ArrayOpR/​issues</a>
</li>
</ul>
</div>
<div class="license">
<h2>License</h2>
<ul class="list-unstyled">
<li><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></li>
</ul>
</div>
<div class="developers">
<h2>Developers</h2>
<ul class="list-unstyled">
<li> Paradigm4 <br><small class="roles"> Maintainer </small>  </li>
<li><a href="authors.html">All authors...</a></li>
</ul>
</div>

  </div>
</div>


      <footer><div class="copyright">
  <p>Developed by  Paradigm4.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.9000.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
